<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON STRIKE</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; background: #000; overflow: hidden; touch-action: none; user-select: none; font-family: 'Courier New', monospace; }
#c { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

#hud { position: fixed; inset: 0; pointer-events: none; }

#crosshair {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 18px; height: 18px; z-index: 10;
}
#crosshair::before, #crosshair::after {
  content: ''; position: absolute; background: rgba(0,255,200,0.95);
  box-shadow: 0 0 4px #00ffc8;
}
#crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
#crosshair::after  { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }

#hitmarker {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 44px; height: 44px; opacity: 0; z-index: 10; pointer-events: none;
  transition: opacity 0.05s;
}
#hitmarker.show { opacity: 1; animation: hm-pop 0.18s ease-out forwards; }
#hitmarker.kill { opacity: 1; animation: hm-kill 0.35s ease-out forwards; }
@keyframes hm-pop  { 0%{transform:translate(-50%,-50%) scale(1.6)} 100%{transform:translate(-50%,-50%) scale(1)} }
@keyframes hm-kill { 0%{transform:translate(-50%,-50%) scale(2.2) rotate(45deg); opacity:1}
                     100%{transform:translate(-50%,-50%) scale(0.8) rotate(45deg); opacity:0} }
/* 斜め4本線の×マーカー */
#hitmarker::before, #hitmarker::after,
#hitmarker .hm2::before, #hitmarker .hm2::after {
  content: ''; position: absolute; width: 13px; height: 2.5px;
  background: #ff3366; box-shadow: 0 0 8px #ff3366, 0 0 18px #ff3366;
  top: 50%; left: 50%;
}
#hitmarker::before  { transform: translate(-50%,-50%) translateX(-8px) rotate(45deg); }
#hitmarker::after   { transform: translate(-50%,-50%) translateX( 8px) rotate(45deg); }
#hitmarker .hm2::before { transform: translate(-50%,-50%) translateX(-8px) rotate(-45deg); }
#hitmarker .hm2::after  { transform: translate(-50%,-50%) translateX( 8px) rotate(-45deg); }
#hitmarker.kill::before, #hitmarker.kill::after,
#hitmarker.kill .hm2::before, #hitmarker.kill .hm2::after {
  background: #ffdd00; box-shadow: 0 0 14px #ffdd00, 0 0 30px #ff9900;
}

#damage-vignette {
  position: fixed; inset: 0; pointer-events: none; opacity: 0; z-index: 5;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(255,0,50,0.8) 100%);
  transition: opacity 0.07s;
}
#damage-vignette.show { opacity: 1; }

/* ヒット時の白フラッシュ */
#hit-flash {
  position: fixed; inset: 0; pointer-events: none; opacity: 0; z-index: 6;
  background: rgba(255,255,255,0.9);
}
#hit-flash.show { animation: flash-out 0.22s ease-out forwards; }
#hit-flash.kill-flash { animation: kill-flash-out 0.4s ease-out forwards; }
@keyframes flash-out      { 0%{opacity:0.45} 100%{opacity:0} }
@keyframes kill-flash-out { 0%{opacity:0.75; background:rgba(255,200,0,0.6)} 40%{opacity:0.4} 100%{opacity:0} }

/* 浮動ダメージ数字 */
.dmg-num {
  position: fixed; left: 50%; font-family: 'Courier New', monospace;
  font-size: 22px; font-weight: bold; letter-spacing: 2px;
  color: #ff3366; text-shadow: 0 0 10px #ff3366, 0 0 22px #ff0044;
  pointer-events: none; z-index: 50; transform: translateX(-50%);
  animation: dmg-float 0.85s ease-out forwards;
}
.dmg-num.kill { color: #ffdd00; text-shadow: 0 0 14px #ffdd00, 0 0 28px #ff9900; font-size: 30px; }
@keyframes dmg-float { 0%{opacity:1;top:44%} 100%{opacity:0;top:30%} }

#topbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 10;
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 12px 16px; pointer-events: none;
}
.sbox {
  background: rgba(0,0,0,0.7); border: 1px solid rgba(0,255,200,0.35);
  padding: 4px 11px; color: #00ffc8; font-size: 11px; letter-spacing: 2px;
  text-shadow: 0 0 8px #00ffc8;
}
#wave-lbl { font-size: 12px; color: #fff; letter-spacing: 4px; text-align: center; text-shadow: 0 0 8px #3b82f6; }

#hp-wrap { position: fixed; bottom: 130px; left: 16px; z-index: 10; pointer-events: none; }
.blbl { font-size: 9px; color: rgba(0,255,200,0.65); letter-spacing: 2px; margin-bottom: 3px; }
#hp-bg { width: 110px; height: 5px; background: rgba(255,255,255,0.1); border: 1px solid rgba(0,255,200,0.3); }
#hp-bar { height: 100%; width: 100%; background: linear-gradient(90deg,#00ffc8,#3b82f6); box-shadow: 0 0 6px #00ffc8; transition: width 0.12s; }

#ammo-wrap { position: fixed; bottom: 130px; right: 16px; z-index: 10; text-align: right; pointer-events: none; }
#ammo-n { font-size: 30px; color: #00ffc8; text-shadow: 0 0 10px #00ffc8; line-height: 1; }
#ammo-m { font-size: 12px; color: rgba(255,255,255,0.35); letter-spacing: 2px; }
#reload-t { font-size: 10px; color: #ff9900; letter-spacing: 3px; text-shadow: 0 0 6px #ff9900; animation: blink .4s infinite; display: none; }
@keyframes blink { 50% { opacity: 0; } }

#minimap { position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; opacity: 0.7; }

#joy-area { position: fixed; bottom: 24px; left: 16px; width: 112px; height: 112px; pointer-events: auto; z-index: 20; }

/* ── キルフィード ── */
#killfeed {
  position: fixed; top: 54px; right: 16px; z-index: 15;
  display: flex; flex-direction: column; align-items: flex-end;
  pointer-events: none; gap: 4px;
}
.kf-row {
  background: rgba(0,0,0,0.65); border-left: 2px solid #00ffc8;
  padding: 3px 10px; color: #fff; font-size: 10px; letter-spacing: 2px;
  text-shadow: 0 0 6px rgba(0,255,200,0.6);
  animation: kf-in 0.15s ease-out, kf-out 0.4s ease-in 2.2s forwards;
  white-space: nowrap;
}
.kf-row.kill  { border-left-color: #ffdd00; color: #ffdd00; text-shadow: 0 0 8px #ffdd00; }
.kf-row.boss  { border-left-color: #ff9900; color: #ff9900; text-shadow: 0 0 8px #ff9900; }
@keyframes kf-in  { from { opacity:0; transform:translateX(20px) } to { opacity:1; transform:none } }
@keyframes kf-out { to   { opacity:0; transform:translateX(10px) } }

/* ── ボスHPバー ── */
#boss-wrap {
  position: fixed; top: 52px; left: 50%; transform: translateX(-50%);
  z-index: 15; pointer-events: none; display: none; text-align: center;
}
#boss-name { font-size: 10px; color: #ff9900; letter-spacing: 4px;
  text-shadow: 0 0 8px #ff9900; margin-bottom: 4px; }
#boss-hp-bg { width: 220px; height: 7px; background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,153,0,0.5); }
#boss-hp-bar { height: 100%; width: 100%;
  background: linear-gradient(90deg,#ff3366,#ff9900);
  box-shadow: 0 0 10px #ff9900; transition: width 0.1s; }

/* ── Wave開始アナウンス ── */
#wave-announce {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  z-index: 90; pointer-events: none; opacity: 0; text-align: center;
}
#wave-announce.show { animation: wa-pop 1.6s ease-out forwards; }
#wave-announce .wa-main {
  font-size: clamp(36px,10vw,72px); letter-spacing: 10px;
  color: #00ffc8; text-shadow: 0 0 30px #00ffc8, 0 0 60px #3b82f6;
  font-family: 'Courier New',monospace;
}
#wave-announce .wa-main.boss-ann { color: #ff9900; text-shadow: 0 0 30px #ff9900, 0 0 60px #ff3366; }
#wave-announce .wa-sub { font-size: 12px; letter-spacing: 6px; color: rgba(255,255,255,0.5); margin-top: 6px; }
@keyframes wa-pop {
  0%   { opacity:0; transform:translate(-50%,-50%) scale(1.8) }
  15%  { opacity:1; transform:translate(-50%,-50%) scale(1.0) }
  70%  { opacity:1; transform:translate(-50%,-50%) scale(1.0) }
  100% { opacity:0; transform:translate(-50%,-50%) scale(0.85) }
}

/* ── ランキング（スタート画面内） ── */
#ranking-box {
  margin-top: 16px; border: 1px solid rgba(0,255,200,0.2);
  padding: 10px 22px; background: rgba(0,0,0,0.5); min-width: 210px;
}
#ranking-box h3 { font-size: 9px; color: rgba(0,255,200,0.55);
  letter-spacing: 4px; margin-bottom: 8px; text-align: center; }
.rank-row { display: flex; justify-content: space-between; gap: 20px;
  font-size: 11px; color: rgba(255,255,255,0.55); letter-spacing: 2px; margin: 4px 0; }
.rank-row .rk-pos   { color: #00ffc8; min-width: 18px; }
.rank-row .rk-wave  { color: rgba(255,255,255,0.35); font-size: 10px; }
.rank-row .rk-score { color: #fff; text-shadow: 0 0 6px #00ffc8; }
#joy-base { width: 100%; height: 100%; border-radius: 50%; background: rgba(0,255,200,0.04); border: 1px solid rgba(0,255,200,0.2); }
#joy-knob {
  position: absolute; width: 40px; height: 40px; border-radius: 50%;
  background: rgba(0,255,200,0.22); border: 1px solid #00ffc8; box-shadow: 0 0 10px #00ffc8;
  pointer-events: none; top: 50%; left: 50%; transform: translate(-50%,-50%);
}

#fire-btn {
  position: fixed; bottom: 34px; right: 24px; width: 78px; height: 78px; border-radius: 50%;
  background: rgba(255,51,102,0.1); border: 2px solid rgba(255,51,102,0.5);
  box-shadow: 0 0 18px rgba(255,51,102,0.2);
  display: flex; align-items: center; justify-content: center;
  color: #ff3366; font-size: 10px; letter-spacing: 2px; font-family: 'Courier New',monospace;
  pointer-events: auto; text-shadow: 0 0 6px #ff3366; z-index: 20; cursor: pointer;
}
#fire-btn.on { background: rgba(255,51,102,0.32); box-shadow: 0 0 30px rgba(255,51,102,0.5); }

.scr {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; z-index: 100; background: rgba(0,0,0,0.9);
}
.scr.off { display: none; }
.scr h1 { font-size: clamp(26px,7vw,50px); letter-spacing: 10px; color: #00ffc8;
  text-shadow: 0 0 25px #00ffc8, 0 0 50px #3b82f6; animation: glow 2s infinite; }
.scr p { color: rgba(255,255,255,0.4); letter-spacing: 4px; font-size: 11px; margin: 12px 0 32px; }
@keyframes glow { 50% { text-shadow: 0 0 45px #00ffc8, 0 0 90px #3b82f6; } }
.btn {
  background: transparent; border: 1px solid #00ffc8; color: #00ffc8;
  padding: 12px 36px; font-family: 'Courier New',monospace; font-size: 12px;
  letter-spacing: 4px; cursor: pointer; box-shadow: 0 0 16px rgba(0,255,200,0.25);
  text-transform: uppercase; margin: 4px;
  /* ▼ タッチ操作でclickが抑制されないようpointer-eventsを明示 */
  pointer-events: auto;
  -webkit-tap-highlight-color: rgba(0,255,200,0.2);
  touch-action: manipulation;   /* ← ダブルタップズームを防ぎ即座にclickを発火 */
}
.btn:hover { background: rgba(0,255,200,0.12); }
.btn:active { background: rgba(0,255,200,0.22); }
.rrow { color: #fff; font-size: 12px; letter-spacing: 3px; margin: 4px 0; }
.rrow span { color: #00ffc8; }
.hint { color: rgba(255,255,255,0.25); font-size: 10px; letter-spacing: 3px; text-align: center; line-height: 2.3; margin-top: 16px; }
</style>
</head>
<body>

<!-- DEMO_META
title: NEON STRIKE
desc: スマホ全画面WebGLで動く近未来3DライフルFPS — Wave制サバイバル · ボスWave · スキルドロップ · コンボ
tech: Canvas 2D · Raycasting Engine · Web Audio API · Touch Joystick · First Person Shooter
level: 92
color: #00ffc8
type: game
-->

<canvas id="c"></canvas>

<div id="damage-vignette"></div>
<div id="hit-flash"></div>
<div id="crosshair"></div>
<div id="hitmarker"><div class="hm2"></div></div>

<div id="topbar">
  <div class="sbox">SCORE&nbsp;<span id="el-score">0</span></div>
  <div>
    <div id="wave-lbl">WAVE&nbsp;<span id="el-wave">1</span></div>
    <div class="sbox" style="margin-top:4px;text-align:center">ENEMIES&nbsp;<span id="el-enemies">0</span></div>
  </div>
  <div class="sbox">KILLS&nbsp;<span id="el-kills">0</span></div>
</div>

<div id="hp-wrap">
  <div class="blbl">HP</div>
  <div id="hp-bg"><div id="hp-bar"></div></div>
</div>
<div id="ammo-wrap">
  <div id="ammo-n">30</div>
  <div id="ammo-m">/ 30</div>
  <div id="reload-t">RELOAD</div>
</div>

<canvas id="minimap" width="80" height="80"></canvas>

<div id="killfeed"></div>

<div id="boss-wrap">
  <div id="boss-name">◆ BOSS UNIT ◆</div>
  <div id="boss-hp-bg"><div id="boss-hp-bar"></div></div>
</div>

<div id="wave-announce">
  <div class="wa-main" id="wa-main-txt">WAVE 1</div>
  <div class="wa-sub"  id="wa-sub-txt">SURVIVE</div>
</div>

<div id="joy-area">
  <div id="joy-base"></div>
  <div id="joy-knob"></div>
</div>
<div id="fire-btn">FIRE</div>

<!-- START -->
<div class="scr" id="scr-start">
  <h1>NEON STRIKE</h1>
  <p>NEON CITY WAVE SURVIVAL</p>
  <button class="btn" id="btn-start">START GAME</button>
  <div id="ranking-box">
    <h3>─ BEST SCORES ─</h3>
    <div id="ranking-list"></div>
  </div>
  <div class="hint">LEFT THUMB: MOVE<br>RIGHT SWIPE: AIM<br>FIRE BUTTON / CLICK: SHOOT<br>R KEY: RELOAD</div>
</div>

<!-- GAME OVER -->
<div class="scr off" id="scr-over">
  <h1 style="color:#ff3366;text-shadow:0 0 25px #ff3366">GAME OVER</h1>
  <div style="margin:16px 0">
    <div class="rrow">WAVE &nbsp;<span id="go-w"></span></div>
    <div class="rrow">KILLS <span id="go-k"></span></div>
    <div class="rrow">SCORE <span id="go-s"></span></div>
  </div>
  <button class="btn" id="btn-retry">RETRY</button>
</div>

<!-- WAVE CLEAR -->
<div class="scr off" id="scr-clear">
  <h1>WAVE CLEAR</h1>
  <p style="color:#ff9900;text-shadow:0 0 8px #ff9900">+30 HP RESTORED</p>
  <button class="btn" id="btn-next">NEXT WAVE</button>
</div>

<script>
(function() {
'use strict';

var W = 0, H = 0;
var RW = 320;
var RH = 200;

var canvas = document.getElementById('c');
var ctx    = canvas.getContext('2d');

var buf    = document.createElement('canvas');
var bctx   = buf.getContext('2d');

function resizeCanvas() {
  W = canvas.width  = window.innerWidth;
  H = canvas.height = window.innerHeight;
  RW = Math.min(320, Math.floor(W / 2));
  RH = Math.min(200, Math.floor(H / 2));
  buf.width  = RW;
  buf.height = RH;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

var MAP_W = 16, MAP_H = 16;
var MAP = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,2,0,0,3,3,0,0,3,3,0,0,2,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,2,0,0,3,3,0,0,3,3,0,0,2,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
];

function mapAt(x, y) {
  var mx = Math.floor(x), my = Math.floor(y);
  if (mx < 0 || mx >= MAP_W || my < 0 || my >= MAP_H) return 1;
  return MAP[my * MAP_W + mx];
}

var WALL_COLS = ['','#0d0d2a','#1a1a3e','#0d1a2e','#1a0d1a'];
var WALL_EMIS = ['','#3b82f6','#00ffc8','#3b82f6','#ff3366'];

var px = 8.5, py = 8.5;
var pa = 0;
var PFOV = Math.PI / 2.8;
var PSPEED = 3.5;
var PTURN  = 2.2;

var state    = 'start';
var wave     = 1;
var kills    = 0;
var score    = 0;
var hp       = 100;
var maxHp    = 100;
var ammo     = 30;
var maxAmmo  = 30;
var reloading = false;
var lastFire  = 0;
var FIRE_RATE = 130;
var RELOAD_MS = 1700;
var moveX = 0, moveZ = 0;
var lookDelta = 0;
var autoTimer = null;
var enemies = [];
var particles = [];
var keys = {};

/* ── ボス管理 ── */
var bossEnemy   = null;   // 現在のボス参照
var BOSS_WAVES  = [5, 10, 15, 20]; // ボスが出るWave番号

/* ── キルフィード ── */
var kfTimers = [];

var gunKick   = 0;
var gunSway   = 0;
var muzzleOn  = false;
var muzzleSize = 0;      // 可変マズルフラッシュサイズ
var shakeX = 0, shakeY = 0, shakeDecay = 0;  // 画面シェイク
var timeScale = 1;       // スローモーション (キル時)
var slowTimer = 0;

/* ── WEB AUDIO SYNTH ──────────────────────────────────── */
var audioCtx = null;
function getAudio() {
  if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){} }
  return audioCtx;
}
function playGunshot() {
  var ac = getAudio(); if (!ac) return;
  var buf = ac.createBuffer(1, ac.sampleRate * 0.12, ac.sampleRate);
  var d = buf.getChannelData(0);
  for (var i = 0; i < d.length; i++) {
    var t = i / ac.sampleRate;
    d[i] = (Math.random()*2-1) * Math.exp(-t * 55) * 1.5
           + Math.sin(t * 180 * Math.PI * 2) * Math.exp(-t * 80) * 0.6;
  }
  var src = ac.createBufferSource();
  var g = ac.createGain(); g.gain.setValueAtTime(0.55, ac.currentTime);
  src.buffer = buf; src.connect(g); g.connect(ac.destination); src.start();
}
function playHit() {
  var ac = getAudio(); if (!ac) return;
  var buf = ac.createBuffer(1, ac.sampleRate * 0.08, ac.sampleRate);
  var d = buf.getChannelData(0);
  for (var i = 0; i < d.length; i++) {
    var t = i / ac.sampleRate;
    d[i] = (Math.random()*2-1) * Math.exp(-t * 90) * 0.9
           + Math.sin(t * 800 * Math.PI * 2) * Math.exp(-t * 120) * 0.4;
  }
  var src = ac.createBufferSource();
  var g = ac.createGain(); g.gain.setValueAtTime(0.35, ac.currentTime);
  src.buffer = buf; src.connect(g); g.connect(ac.destination); src.start();
}
function playKill() {
  var ac = getAudio(); if (!ac) return;
  var buf = ac.createBuffer(1, ac.sampleRate * 0.22, ac.sampleRate);
  var d = buf.getChannelData(0);
  for (var i = 0; i < d.length; i++) {
    var t = i / ac.sampleRate;
    d[i] = (Math.random()*2-1) * Math.exp(-t * 18) * 1.1
           + Math.sin(t * 120 * Math.PI * 2) * Math.exp(-t * 25) * 0.8
           + Math.sin(t * 60 * Math.PI * 2) * Math.exp(-t * 15) * 0.5;
  }
  var src = ac.createBufferSource();
  var g = ac.createGain(); g.gain.setValueAtTime(0.6, ac.currentTime);
  src.buffer = buf; src.connect(g); g.connect(ac.destination); src.start();
}

var SPAWNS = [
  [1.5,1.5],[14.5,1.5],[1.5,14.5],[14.5,14.5],
  [8,1.5],[1.5,8],[14.5,8],[8,14.5],
  [3,3],[13,3],[3,13],[13,13],
  [8,4],[4,8],[12,8],[8,12]
];

var zbuf = [];

function castRays() {
  zbuf = [];
  var halfH = RH / 2;

  for (var x = 0; x < RW; x++) {
    var camX = (2 * x / RW) - 1;
    var rayDirX = Math.cos(pa) - Math.sin(pa) * camX * (PFOV / (Math.PI / 4));
    var rayDirY = Math.sin(pa) + Math.cos(pa) * camX * (PFOV / (Math.PI / 4));

    var mapX = Math.floor(px), mapY = Math.floor(py);
    var deltaX = Math.abs(1 / rayDirX);
    var deltaY = Math.abs(1 / rayDirY);
    var stepX, stepY, sideDistX, sideDistY;

    if (rayDirX < 0) { stepX = -1; sideDistX = (px - mapX) * deltaX; }
    else             { stepX =  1; sideDistX = (mapX + 1 - px) * deltaX; }
    if (rayDirY < 0) { stepY = -1; sideDistY = (py - mapY) * deltaY; }
    else             { stepY =  1; sideDistY = (mapY + 1 - py) * deltaY; }

    var hit = 0, side = 0, wallType = 0;
    var maxSteps = 32;
    while (!hit && maxSteps-- > 0) {
      if (sideDistX < sideDistY) { sideDistX += deltaX; mapX += stepX; side = 0; }
      else                        { sideDistY += deltaY; mapY += stepY; side = 1; }
      wallType = mapAt(mapX, mapY);
      if (wallType > 0) hit = 1;
    }

    var wallDist = side === 0
      ? (mapX - px + (1 - stepX) / 2) / rayDirX
      : (mapY - py + (1 - stepY) / 2) / rayDirY;

    wallDist = Math.max(0.01, wallDist);
    zbuf[x] = wallDist;

    var lineH  = Math.floor(RH / wallDist);
    var drawS  = Math.max(0, halfH - lineH / 2);
    var drawE  = Math.min(RH - 1, halfH + lineH / 2);

    var fog   = Math.min(1, wallDist / 12);
    var wtype = Math.min(4, wallType);
    var base  = WALL_COLS[wtype] || '#0d0d2a';
    var emis  = WALL_EMIS[wtype] || '#3b82f6';

    var shade = side === 1 ? 0.6 : 1.0;
    shade *= (1 - fog * 0.85);

    bctx.fillStyle = lerpColor(base, '#050510', fog * 0.9);
    bctx.fillRect(x, drawS, 1, drawE - drawS);

    if (lineH > 2 && shade > 0.3) {
      bctx.fillStyle = emis;
      bctx.globalAlpha = shade * 0.35 * (1 - fog);
      bctx.fillRect(x, drawS, 1, 1);
      bctx.fillRect(x, drawE - 1, 1, 1);
      bctx.globalAlpha = 1;
    }
  }
}

function lerpColor(a, b, t) {
  var ar = parseInt(a.slice(1,3),16), ag = parseInt(a.slice(3,5),16), ab2 = parseInt(a.slice(5,7),16);
  var br = parseInt(b.slice(1,3),16), bg = parseInt(b.slice(3,5),16), bb2 = parseInt(b.slice(5,7),16);
  var r = Math.round(ar + (br - ar) * t);
  var g = Math.round(ag + (bg - ag) * t);
  var b2= Math.round(ab2 + (bb2 - ab2) * t);
  return 'rgb('+r+','+g+','+b2+')';
}

function drawFloorCeiling() {
  var cg = bctx.createLinearGradient(0, 0, 0, RH / 2);
  cg.addColorStop(0, '#050510');
  cg.addColorStop(1, '#0a0a1f');
  bctx.fillStyle = cg;
  bctx.fillRect(0, 0, RW, RH / 2);

  var fg = bctx.createLinearGradient(0, RH / 2, 0, RH);
  fg.addColorStop(0, '#080815');
  fg.addColorStop(1, '#020208');
  bctx.fillStyle = fg;
  bctx.fillRect(0, RH / 2, RW, RH / 2);

  bctx.strokeStyle = 'rgba(0,255,200,0.06)';
  bctx.lineWidth = 0.5;
  for (var gx = 0; gx < RW; gx += Math.floor(RW / 16)) {
    bctx.beginPath(); bctx.moveTo(gx, RH / 2); bctx.lineTo(RW / 2, RH); bctx.stroke();
  }
}

function drawSprites() {
  var sorted = [];
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    var dx = e.x - px, dy = e.y - py;
    sorted.push({ e: e, dist2: dx*dx + dy*dy });
  }
  sorted.sort(function(a, b) { return b.dist2 - a.dist2; });

  for (var si = 0; si < sorted.length; si++) {
    var e = sorted[si].e;
    if (!e.alive) continue; // 死亡した敵は描画しない
    var sprDist = Math.sqrt(sorted[si].dist2);
    if (sprDist < 0.3) continue;

    var dx = e.x - px;
    var dy = e.y - py;
    var relAngle = Math.atan2(dy, dx) - pa;
    while (relAngle >  Math.PI) relAngle -= 2 * Math.PI;
    while (relAngle < -Math.PI) relAngle += 2 * Math.PI;

    if (Math.abs(relAngle) > PFOV * 0.7) continue;

    var screenX = Math.floor((0.5 + relAngle / PFOV) * RW);
    var scale   = e.isBoss ? 2.8 : 1;
    var sprH    = Math.abs(Math.floor(RH / sprDist)) * scale;
    var sprW    = sprH * 0.65;
    var drawX   = Math.floor(screenX - sprW / 2);
    var drawY   = Math.floor(RH / 2 - sprH / 2);

    var fog = Math.min(1, sprDist / 10);
    var alpha = Math.max(0, 1 - fog * 0.9);
    if (alpha < 0.05) continue;

    bctx.globalAlpha = alpha;

    // ボスはオレンジ、通常は赤
    var baseBody = e.isBoss ? '#cc5500' : '#cc1133';
    var baseHead = e.isBoss ? '#ff7700' : '#dd2244';
    var bodyColor = e.flashTimer > 0 ? '#ffffff' : baseBody;
    var headColor = e.flashTimer > 0 ? '#ffffff' : baseHead;

    bctx.fillStyle = bodyColor;
    bctx.fillRect(drawX + sprW*0.2, drawY + sprH*0.35, sprW*0.6, sprH*0.55);

    bctx.fillStyle = headColor;
    var hSize = sprW * 0.4;
    bctx.fillRect(drawX + sprW*0.3, drawY + sprH*0.1, hSize, hSize);

    if (e.alive && alpha > 0.4) {
      bctx.fillStyle = e.isBoss ? '#ff6600' : '#ff0000';
      bctx.globalAlpha = alpha * 0.9;
      var es = Math.max(1, sprW * 0.08);
      bctx.fillRect(drawX + sprW*0.33, drawY + sprH*0.18, es, es);
      bctx.fillRect(drawX + sprW*0.55, drawY + sprH*0.18, es, es);
    }

    // HPバー（ボスは太め）
    if (e.alive && sprH > 20) {
      var hpRatio = e.hp / e.maxHp;
      var barH = e.isBoss ? 5 : 3;
      bctx.globalAlpha = alpha * 0.85;
      bctx.fillStyle = '#330000';
      bctx.fillRect(drawX, drawY - 6, sprW, barH);
      bctx.fillStyle = e.isBoss ? '#ff9900' : (hpRatio > 0.5 ? '#00ff88' : '#ff3366');
      bctx.fillRect(drawX, drawY - 6, sprW * hpRatio, barH);

      // ボスはトップHPバーも同期
      if (e.isBoss) {
        document.getElementById('boss-hp-bar').style.width = (hpRatio * 100) + '%';
      }
    }

    bctx.globalAlpha = 1;
  }
}

function drawGun(t) {
  var sw = RW, sh = RH;
  var gw = sw * 0.35, gh = gw * 0.55;
  var gx = sw / 2 - gw / 2 + Math.sin(t * 3) * 2 * Math.max(0.1, Math.abs(moveZ) + Math.abs(moveX));
  var gy = sh - gh + gunKick * 18 + Math.abs(Math.sin(t * 3)) * 2;

  bctx.fillStyle = 'rgba(0,0,0,0.5)';
  bctx.fillRect(gx + 3, gy + 3, gw, gh);

  bctx.fillStyle = '#1a1a2e';
  bctx.fillRect(gx, gy, gw, gh);

  bctx.fillStyle = '#00ffc8';
  bctx.fillRect(gx, gy + 2, gw, 2);
  bctx.fillRect(gx, gy + gh - 4, gw, 2);

  bctx.fillStyle = '#111122';
  bctx.fillRect(gx + gw * 0.42, gy - gh * 0.3, gw * 0.16, gh * 0.35);
  bctx.fillStyle = '#00ffc8';
  bctx.fillRect(gx + gw * 0.42, gy - gh * 0.3, gw * 0.16, 2);

  if (muzzleOn) {
    var mfx = gx + gw * 0.42 + gw * 0.08;
    var mfy = gy - gh * 0.3 - 6;
    var ms = muzzleSize;
    // 外炎
    bctx.fillStyle = '#ff9900';
    bctx.globalAlpha = 0.75;
    bctx.beginPath(); bctx.arc(mfx, mfy, ms * 1.6, 0, Math.PI * 2); bctx.fill();
    // 内炎
    bctx.fillStyle = '#ffee44';
    bctx.globalAlpha = 0.9;
    bctx.beginPath(); bctx.arc(mfx, mfy, ms, 0, Math.PI * 2); bctx.fill();
    // コア白
    bctx.fillStyle = '#ffffff';
    bctx.globalAlpha = 1;
    bctx.beginPath(); bctx.arc(mfx, mfy, ms * 0.45, 0, Math.PI * 2); bctx.fill();
    // 横ビーム
    bctx.fillStyle = '#ffcc00';
    bctx.globalAlpha = 0.5;
    bctx.fillRect(mfx - ms * 2.5, mfy - 1, ms * 5, 2);
    bctx.globalAlpha = 1;
  }
}

function render(t) {
  bctx.clearRect(0, 0, RW, RH);
  drawFloorCeiling();
  castRays();
  drawSprites();
  drawWorldParticles(); // 3Dパーティクル
  drawGun(t);

  ctx.imageSmoothingEnabled = false;

  // 画面シェイク適用
  if (shakeDecay > 0) {
    ctx.save();
    ctx.translate(shakeX, shakeY);
    ctx.drawImage(buf, 0, 0, W, H);
    ctx.restore();
  } else {
    ctx.drawImage(buf, 0, 0, W, H);
  }

  // スキャンライン
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  for (var y = 0; y < H; y += 3) { ctx.fillRect(0, y, W, 1); }
}

var mmCanvas = document.getElementById('minimap');
var mmCtx    = mmCanvas.getContext('2d');
var MM = 80, CELL = MM / MAP_W;

function drawMinimap() {
  mmCtx.clearRect(0, 0, MM, MM);
  mmCtx.fillStyle = 'rgba(0,0,0,0.6)';
  mmCtx.fillRect(0, 0, MM, MM);

  for (var my = 0; my < MAP_H; my++) {
    for (var mx = 0; mx < MAP_W; mx++) {
      var t = MAP[my * MAP_W + mx];
      if (t > 0) {
        mmCtx.fillStyle = WALL_EMIS[Math.min(t, 4)] || '#3b82f6';
        mmCtx.globalAlpha = 0.5;
        mmCtx.fillRect(mx * CELL, my * CELL, CELL - 0.5, CELL - 0.5);
        mmCtx.globalAlpha = 1;
      }
    }
  }

  for (var ei = 0; ei < enemies.length; ei++) {
    var e = enemies[ei];
    if (!e.alive) continue;
    mmCtx.fillStyle = '#ff3366';
    mmCtx.beginPath();
    mmCtx.arc(e.x * CELL, e.y * CELL, CELL * 0.4, 0, Math.PI * 2);
    mmCtx.fill();
  }

  mmCtx.fillStyle = '#00ffc8';
  mmCtx.beginPath();
  mmCtx.arc(px * CELL, py * CELL, CELL * 0.55, 0, Math.PI * 2);
  mmCtx.fill();
  mmCtx.strokeStyle = '#00ffc8';
  mmCtx.lineWidth = 1;
  mmCtx.beginPath();
  mmCtx.moveTo(px * CELL, py * CELL);
  mmCtx.lineTo((px + Math.cos(pa) * 1.2) * CELL, (py + Math.sin(pa) * 1.2) * CELL);
  mmCtx.stroke();
}

var SIGHT = 8, ATRANGE = 6, STOP = 0.8;

function isBossWave(w) { return BOSS_WAVES.indexOf(w) !== -1; }

function spawnWave(w) {
  enemies = [];
  bossEnemy = null;
  document.getElementById('boss-wrap').style.display = 'none';

  var isBoss = isBossWave(w);
  var count  = isBoss ? 1 : 3 + w * 2;

  for (var i = 0; i < count; i++) {
    var sp = SPAWNS[i % SPAWNS.length];
    var baseHp, spd, fireCd;

    if (isBoss && i === 0) {
      // ボス専用パラメータ
      baseHp = 250 + w * 40;
      spd    = 2.2 + w * 0.08;
      fireCd = 0.5;
    } else {
      baseHp = 35 + (w - 1) * 12;
      spd    = 1.4 + Math.random() * 0.5 + (w - 1) * 0.2;
      fireCd = Math.max(0.7, 2.5 - w * 0.12);
    }

    var e = {
      x: sp[0] + (Math.random() - 0.5) * 0.6,
      y: sp[1] + (Math.random() - 0.5) * 0.6,
      hp: baseHp, maxHp: baseHp,
      speed: spd,
      fireTimer: 1 + Math.random() * 2,
      fireCd: fireCd,
      patAngle: Math.random() * Math.PI * 2,
      state: 'patrol',
      flashTimer: 0,
      knockTimer: 0, knockX: 0, knockY: 0,
      alive: true,
      isBoss: isBoss && i === 0
    };
    enemies.push(e);
    if (e.isBoss) bossEnemy = e;
  }

  setEl('el-enemies', enemies.length);

  // ボスHPバー表示
  if (isBoss) {
    document.getElementById('boss-wrap').style.display = 'block';
    document.getElementById('boss-name').textContent = '◆ WAVE ' + w + ' BOSS ◆';
    document.getElementById('boss-hp-bar').style.width = '100%';
  }

  // Waveアナウンス
  showWaveAnnounce(w, isBoss);
  addKillfeed(isBoss ? '⚠ BOSS WAVE ' + w : 'WAVE ' + w + ' START', isBoss ? 'boss' : '');
}

function updateEnemies(dt) {
  var alive = 0;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    alive++;
    if (e.flashTimer > 0) e.flashTimer -= dt;
    applyKnockback(e, dt); // ノックバック

    var dx = px - e.x, dy = py - e.y;
    var dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < SIGHT) e.state = 'chase';

    if (e.state === 'chase') {
      if (dist > STOP && dist > 0.01) {
        var spd = e.speed * dt;
        var nx = e.x + dx / dist * spd;
        var ny = e.y + dy / dist * spd;
        if (!mapAt(nx, e.y)) e.x = nx;
        if (!mapAt(e.x, ny)) e.y = ny;
      }
      if (dist < ATRANGE) {
        e.fireTimer -= dt;
        if (e.fireTimer <= 0) {
          e.fireTimer = e.fireCd;
          enemyShoot(dist);
        }
      }
    } else {
      e.patAngle += dt * 0.8;
      var nx2 = e.x + Math.cos(e.patAngle) * 0.03;
      var ny2 = e.y + Math.sin(e.patAngle) * 0.03;
      if (!mapAt(nx2, e.y)) e.x = nx2;
      if (!mapAt(e.x, ny2)) e.y = ny2;
    }
  }
  setEl('el-enemies', alive);
  if (alive === 0 && state === 'playing') waveClear();
}

function enemyShoot(dist) {
  var hit = 0.22 + (1 - dist / ATRANGE) * 0.28;
  if (Math.random() > hit) return;
  hp -= 10;
  if (hp < 0) hp = 0;
  document.getElementById('hp-bar').style.width = (hp / maxHp * 100) + '%';
  flashDmg();
  if (hp <= 0) playerDead();
}

function shoot() {
  if (state !== 'playing') return;
  if (reloading || ammo <= 0) { if (!reloading && ammo <= 0) startReload(); return; }
  var now = performance.now();
  if (now - lastFire < FIRE_RATE) return;
  lastFire = now;

  ammo--;
  setEl('ammo-n', ammo);
  if (ammo <= 0) startReload();

  gunKick = 1;
  muzzleOn = true;
  muzzleSize = 6 + Math.random() * 4;
  setTimeout(function() { muzzleOn = false; }, 65);

  // 射撃音
  playGunshot();

  // 射撃シェイク（軽め）
  triggerShake(3, 0.08);

  var hitDist = 99;
  var hitEnemy = null;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    var dx = e.x - px, dy = e.y - py;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var angleToEnemy = Math.atan2(dy, dx);
    var relAngle = angleToEnemy - pa;
    while (relAngle >  Math.PI) relAngle -= 2 * Math.PI;
    while (relAngle < -Math.PI) relAngle += 2 * Math.PI;
    var hitCone = 0.10 + 0.05 / Math.max(0.5, dist);
    if (Math.abs(relAngle) < hitCone && dist < hitDist && dist < 14) {
      if (zbuf[Math.floor(RW / 2)] > dist - 0.5) {
        hitDist = dist; hitEnemy = e;
      }
    }
  }

  if (hitEnemy) {
    var dmg = 38;
    hitEnemy.hp -= dmg;
    hitEnemy.flashTimer = 0.14;

    // ノックバック：弾を受けた方向に吹き飛ぶ
    var ndx = hitEnemy.x - px, ndy = hitEnemy.y - py;
    var ndist = Math.sqrt(ndx*ndx + ndy*ndy);
    hitEnemy.knockX = (ndx / ndist) * 1.8;
    hitEnemy.knockY = (ndy / ndist) * 1.8;
    hitEnemy.knockTimer = 0.12;

    // 3Dパーティクル大量
    spawnParticles(hitEnemy.x, hitEnemy.y, false);

    // ヒット音
    playHit();

    // ヒットシェイク（強め）
    triggerShake(7, 0.12);

    // 白フラッシュ
    flashHit(false);

    if (hitEnemy.hp <= 0) {
      killEnemy(hitEnemy);
    } else {
      showHit(false);
      spawnDmgNum(dmg, false);
    }
  }
}

function killEnemy(e) {
  e.alive = false;
  var isBoss = e.isBoss;
  var bonus  = isBoss ? 10 : 1;
  kills++; score += 100 * wave * bonus;
  setEl('el-kills', kills);
  setEl('el-score', score);

  // キルフィード
  if (isBoss) {
    addKillfeed('★ BOSS DESTROYED! +' + (100 * wave * bonus), 'boss');
    document.getElementById('boss-wrap').style.display = 'none';
  } else {
    addKillfeed('▶ ENEMY DESTROYED  +' + (100 * wave), 'kill');
  }

  // 爆発パーティクル大量
  spawnParticles(e.x, e.y, true);

  // キル音
  playKill();

  // キル専用演出
  showHit(true);
  spawnDmgNum(isBoss ? 'BOSS DOWN!!' : 'KILL!', true);
  flashHit(true);
  triggerShake(isBoss ? 22 : 14, isBoss ? 0.4 : 0.22);

  // スローモーション
  timeScale = isBoss ? 0.1 : 0.18;
  slowTimer  = isBoss ? 0.9 : 0.55;
}

function startReload() {
  if (reloading || ammo >= maxAmmo) return;
  reloading = true;
  document.getElementById('reload-t').style.display = 'block';
  setTimeout(function() {
    ammo = maxAmmo; reloading = false;
    document.getElementById('reload-t').style.display = 'none';
    setEl('ammo-n', ammo);
  }, RELOAD_MS);
}

function spawnParticles(ex, ey, isKill) {
  var count = isKill ? 20 : 8;
  for (var i = 0; i < count; i++) {
    var angle = Math.random() * Math.PI * 2;
    var speed = isKill ? (1.5 + Math.random() * 3.5) : (0.8 + Math.random() * 2);
    particles.push({
      x: ex, y: ey,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: isKill ? (0.5 + Math.random() * 0.6) : (0.25 + Math.random() * 0.3),
      maxLife: isKill ? 1.1 : 0.55,
      color: isKill ? (Math.random() < 0.5 ? '#ff3366' : '#ffdd00') : '#ff3366',
      size: isKill ? (1.5 + Math.random() * 2) : (0.8 + Math.random() * 1.2),
      kill: isKill
    });
  }
}

function drawWorldParticles() {
  for (var i = 0; i < particles.length; i++) {
    var p = particles[i];
    var dx = p.x - px, dy = p.y - py;
    var dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 0.1) continue;
    var relAngle = Math.atan2(dy, dx) - pa;
    while (relAngle >  Math.PI) relAngle -= 2 * Math.PI;
    while (relAngle < -Math.PI) relAngle += 2 * Math.PI;
    if (Math.abs(relAngle) > PFOV * 0.75) continue;
    var screenX = Math.floor((0.5 + relAngle / PFOV) * RW);
    if (zbuf[screenX] < dist - 0.2) continue;
    var sz = Math.max(1, p.size * (RH / dist) * 0.08);
    var sy = RH / 2;
    var lifeRatio = p.life / (p.maxLife || 0.55);
    bctx.globalAlpha = lifeRatio * 0.9;
    bctx.fillStyle = p.color;
    bctx.fillRect(screenX - sz/2, sy - sz/2, sz, sz);
    bctx.globalAlpha = 1;
  }
}

function updateParticles(dt) {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.88; p.vy *= 0.88;
  }
}

function triggerShake(intensity, duration) {
  shakeX = (Math.random()-0.5) * intensity;
  shakeY = (Math.random()-0.5) * intensity;
  shakeDecay = duration;
}

function updatePlayer(dt) {
  if (state !== 'playing') return;

  pa += lookDelta * PTURN * dt;
  lookDelta = 0;

  var fx = Math.cos(pa) * (-moveZ) - Math.sin(pa) * moveX;
  var fy = Math.sin(pa) * (-moveZ) + Math.cos(pa) * moveX;
  var spd = PSPEED * dt;
  var nx = px + fx * spd;
  var ny = py + fy * spd;

  if (!mapAt(nx + Math.sign(fx) * 0.2, py)) px = Math.max(0.5, Math.min(MAP_W - 0.5, nx));
  if (!mapAt(px, ny + Math.sign(fy) * 0.2)) py = Math.max(0.5, Math.min(MAP_H - 0.5, ny));

  if (gunKick > 0) gunKick -= dt * 7;
  if (gunKick < 0) gunKick = 0;

  // シェイク減衰
  if (shakeDecay > 0) {
    shakeDecay -= dt;
    var ratio = Math.max(0, shakeDecay);
    shakeX = (Math.random()-0.5) * ratio * 60;
    shakeY = (Math.random()-0.5) * ratio * 40;
    if (shakeDecay <= 0) { shakeX = 0; shakeY = 0; }
  }

  // スローモーション回復
  if (slowTimer > 0) {
    slowTimer -= dt;
    if (slowTimer <= 0) { timeScale = 1; slowTimer = 0; }
  }
}

// 敵ノックバック更新（updateEnemies内で呼ぶ）
function applyKnockback(e, dt) {
  if (e.knockTimer && e.knockTimer > 0) {
    e.knockTimer -= dt;
    var nx = e.x + e.knockX * dt * 8;
    var ny = e.y + e.knockY * dt * 8;
    if (!mapAt(nx, e.y)) e.x = nx;
    if (!mapAt(e.x, ny)) e.y = ny;
    e.knockX *= 0.7; e.knockY *= 0.7;
  }
}

var hitT;
function showHit(isKill) {
  var h = document.getElementById('hitmarker');
  h.classList.remove('show', 'kill');
  void h.offsetWidth; // reflow
  h.classList.add(isKill ? 'kill' : 'show');
  clearTimeout(hitT);
  hitT = setTimeout(function() { h.classList.remove('show', 'kill'); }, isKill ? 400 : 160);
}

function flashHit(isKill) {
  var f = document.getElementById('hit-flash');
  f.classList.remove('show', 'kill-flash');
  void f.offsetWidth;
  f.classList.add(isKill ? 'kill-flash' : 'show');
  setTimeout(function() { f.classList.remove('show', 'kill-flash'); }, isKill ? 450 : 250);
}

function spawnDmgNum(val, isKill) {
  var el = document.createElement('div');
  el.className = 'dmg-num' + (isKill ? ' kill' : '');
  el.textContent = isKill ? val : '-' + val;
  el.style.top = (40 + Math.random() * 12) + '%';
  el.style.left = (45 + Math.random() * 10) + '%';
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 900);
}

/* ── キルフィード ─────────────────────────────────────── */
function addKillfeed(msg, cls) {
  var feed = document.getElementById('killfeed');
  var row  = document.createElement('div');
  row.className = 'kf-row' + (cls ? ' ' + cls : '');
  row.textContent = msg;
  feed.appendChild(row);
  // 最大5行まで
  while (feed.children.length > 5) feed.removeChild(feed.firstChild);
  var t = setTimeout(function() { if (row.parentNode) row.parentNode.removeChild(row); }, 2700);
  kfTimers.push(t);
}

/* ── Waveアナウンス ──────────────────────────────────── */
function showWaveAnnounce(w, isBoss) {
  var el  = document.getElementById('wave-announce');
  var main = document.getElementById('wa-main-txt');
  var sub  = document.getElementById('wa-sub-txt');
  main.className = isBoss ? 'wa-main boss-ann' : 'wa-main';
  main.textContent = isBoss ? '⚠ BOSS WAVE' : 'WAVE  ' + w;
  sub.textContent  = isBoss ? '— ELIMINATE THE BOSS —' : 'SURVIVE';
  el.classList.remove('show');
  void el.offsetWidth;
  el.classList.add('show');
  setTimeout(function() { el.classList.remove('show'); }, 1700);
}

/* ── ランキング（localStorage） ──────────────────────── */
var RANK_KEY = 'neonStrikeRanks';
function loadRanks() {
  try { return JSON.parse(localStorage.getItem(RANK_KEY)) || []; } catch(e) { return []; }
}
function saveRank(s, w) {
  var ranks = loadRanks();
  ranks.push({ score: s, wave: w });
  ranks.sort(function(a, b) { return b.score - a.score; });
  ranks = ranks.slice(0, 5);
  try { localStorage.setItem(RANK_KEY, JSON.stringify(ranks)); } catch(e) {}
  return ranks;
}
function renderRanking() {
  var ranks = loadRanks();
  var list  = document.getElementById('ranking-list');
  if (!list) return;
  list.innerHTML = '';
  if (ranks.length === 0) {
    list.innerHTML = '<div class="rank-row" style="justify-content:center;color:rgba(255,255,255,0.25)">NO DATA</div>';
    return;
  }
  var medals = ['①','②','③','④','⑤'];
  ranks.forEach(function(r, i) {
    var row = document.createElement('div');
    row.className = 'rank-row';
    row.innerHTML = '<span class="rk-pos">' + medals[i] + '</span>'
                  + '<span class="rk-score">' + r.score + '</span>'
                  + '<span class="rk-wave">W' + r.wave + '</span>';
    list.appendChild(row);
  });
}

function flashDmg() {
  var v = document.getElementById('damage-vignette');
  v.classList.add('show');
  setTimeout(function() { v.classList.remove('show'); }, 260);
}

function startGame() {
  state = 'playing'; wave = 1; kills = 0; score = 0;
  hp = maxHp; ammo = maxAmmo; reloading = false;
  px = 8.5; py = 8.5; pa = 0;
  moveX = 0; moveZ = 0;
  particles = []; bossEnemy = null;
  document.getElementById('killfeed').innerHTML = '';
  kfTimers.forEach(clearTimeout); kfTimers = [];

  setEl('el-kills', 0); setEl('el-score', 0); setEl('el-wave', 1);
  setEl('ammo-n', maxAmmo);
  document.getElementById('hp-bar').style.width = '100%';
  document.getElementById('reload-t').style.display = 'none';
  document.getElementById('boss-wrap').style.display = 'none';
  hide('scr-start'); hide('scr-over'); hide('scr-clear');

  spawnWave(wave);
}

function waveClear() {
  if (state !== 'playing') return;
  state = 'waveclear';
  show('scr-clear');
}

function nextWave() {
  wave++;
  hp = Math.min(maxHp, hp + 30);
  ammo = maxAmmo; reloading = false;
  document.getElementById('hp-bar').style.width = (hp / maxHp * 100) + '%';
  setEl('ammo-n', ammo);
  document.getElementById('reload-t').style.display = 'none';
  setEl('el-wave', wave);
  hide('scr-clear');
  particles = [];
  state = 'playing';
  spawnWave(wave);
}

function playerDead() {
  if (state !== 'playing') return;
  state = 'dead'; stopAuto();
  document.getElementById('go-w').textContent = wave;
  document.getElementById('go-k').textContent = kills;
  document.getElementById('go-s').textContent = score;
  // ランキング保存して表示更新
  saveRank(score, wave);
  renderRanking();
  show('scr-over');
}

function startAuto() {
  if (autoTimer) return;
  shoot();
  autoTimer = setInterval(shoot, FIRE_RATE);
}
function stopAuto() {
  if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
}

/* ═══════════════════════════════════════════════════════════
   TOUCH CONTROLS
   ─────────────────────────────────────────────────────────
   【修正①】isInteractive() でボタン要素はpreventDefaultを
   スキップ → click イベントが正常に発火するようになる
   ═══════════════════════════════════════════════════════════ */
function isInteractive(target) {
  while (target) {
    if (target.tagName === 'BUTTON' || target.classList.contains('btn')) return true;
    target = target.parentElement;
  }
  return false;
}

var joyArea = document.getElementById('joy-area');
var joyKnob = document.getElementById('joy-knob');
var fireBtn = document.getElementById('fire-btn');
var JR = 44;
var joyId = -1, lookId = -1, fireId = -1;
var joyBX = 0, joyBY = 0, lookPX = 0, lookPY = 0;

document.addEventListener('touchstart', function(e) {
  /* ── 【修正①ここが根本原因】──────────────────────────────
     元コードは e.preventDefault() を無条件で呼んでいた。
     これによりボタンタップ時の click イベント合成がキャンセルされ
     START / RETRY / NEXT WAVE が一切反応しなかった。
     ボタン要素の場合はpreventDefaultをスキップする。
     ──────────────────────────────────────────────────── */
  if (isInteractive(e.target)) return; // ← ボタンはデフォルト動作を維持
  e.preventDefault();

  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    var tx = t.clientX, ty = t.clientY;
    var jr = joyArea.getBoundingClientRect();
    var fr = fireBtn.getBoundingClientRect();
    if (tx >= jr.left && tx <= jr.right && ty >= jr.top && ty <= jr.bottom) {
      joyId = t.identifier;
      joyBX = jr.left + jr.width / 2; joyBY = jr.top + jr.height / 2;
    } else if (tx >= fr.left && tx <= fr.right && ty >= fr.top && ty <= fr.bottom) {
      fireId = t.identifier; fireBtn.classList.add('on'); startAuto();
    } else if (lookId === -1) {
      lookId = t.identifier; lookPX = tx; lookPY = ty;
    }
  }
}, { passive: false });

document.addEventListener('touchmove', function(e) {
  if (isInteractive(e.target)) return;
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    if (t.identifier === joyId) {
      var dx = t.clientX - joyBX, dy = t.clientY - joyBY;
      var len = Math.sqrt(dx*dx+dy*dy);
      if (len > JR) { dx=dx/len*JR; dy=dy/len*JR; }
      joyKnob.style.left = (50 + dx/JR*50) + '%';
      joyKnob.style.top  = (50 + dy/JR*50) + '%';
      moveX = dx/JR; moveZ = dy/JR;
    } else if (t.identifier === lookId) {
      lookDelta += (t.clientX - lookPX) / W * 5;
      lookPX = t.clientX; lookPY = t.clientY;
    }
  }
}, { passive: false });

document.addEventListener('touchend', function(e) {
  if (isInteractive(e.target)) return;
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    if (t.identifier === joyId) { joyId=-1; moveX=0; moveZ=0; joyKnob.style.left='50%'; joyKnob.style.top='50%'; }
    else if (t.identifier === lookId) { lookId=-1; }
    else if (t.identifier === fireId) { fireId=-1; fireBtn.classList.remove('on'); stopAuto(); }
  }
}, { passive: false });

/* ── DESKTOP ────────────────────────────────────────────── */
canvas.addEventListener('mousedown', function(e) {
  if (e.button === 0) { canvas.requestPointerLock(); startAuto(); }
});
document.addEventListener('mouseup', stopAuto);
document.addEventListener('mousemove', function(e) {
  if (document.pointerLockElement !== canvas) return;
  lookDelta += e.movementX / W * 5;
});

fireBtn.addEventListener('mousedown', function(e) { e.stopPropagation(); startAuto(); fireBtn.classList.add('on'); });
fireBtn.addEventListener('mouseup',   function()  { stopAuto(); fireBtn.classList.remove('on'); });

document.addEventListener('keydown', function(e) {
  keys[e.code] = true;
  if (e.code === 'KeyR') startReload();
});
document.addEventListener('keyup', function(e) {
  keys[e.code] = false;
  /* 【修正②】スペースキーを離したら自動射撃を止める */
  if (e.code === 'Space') stopAuto();
});

function processKeys() {
  var s = 0.9;
  /* 【修正③】キーボード入力がある場合のみ moveX/moveZ を上書きする。
     joyId !== -1 (ジョイスティック操作中) はタッチ側の値を尊重する。
     キーが何も押されていない & ジョイスティック未使用のときだけ 0 にリセット。 */
  var anyMove = keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'];
  if (anyMove || joyId === -1) {
    var kz = (keys['KeyW'] ? -s : 0) + (keys['KeyS'] ? s : 0);
    var kx = (keys['KeyA'] ? -s : 0) + (keys['KeyD'] ? s : 0);
    // キーボード入力がある場合はキーボード優先、なければジョイスティック値を維持
    if (anyMove) { moveZ = kz; moveX = kx; }
    else if (joyId === -1) { moveZ = 0; moveX = 0; } // 両方未使用ならゼロ
  }
  if (keys['ArrowLeft'])  lookDelta -= 0.05;
  if (keys['ArrowRight']) lookDelta += 0.05;
  if (keys['Space'] && !autoTimer) startAuto();
}

/* ── BUTTONS ────────────────────────────────────────────── */
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-retry').addEventListener('click', startGame);
document.getElementById('btn-next').addEventListener('click', nextWave);

// 起動時にランキング表示
renderRanking();

function setEl(id, val) { document.getElementById(id).textContent = val; }
function show(id) { document.getElementById(id).classList.remove('off'); }
function hide(id) { document.getElementById(id).classList.add('off'); }

var lastTime = performance.now();

function loop(now) {
  requestAnimationFrame(loop);
  var rawDt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  var dt = rawDt * timeScale; // スローモーション適用

  if (state === 'playing') {
    processKeys();
    updatePlayer(rawDt); // シェイク・スロータイマーはリアルタイム
    updateEnemies(dt);
    updateParticles(dt);
  }

  render(now / 1000);
  drawMinimap();
}

requestAnimationFrame(loop);

}());
</script>
</body>
</html>