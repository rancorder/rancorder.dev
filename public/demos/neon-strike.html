<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON STRIKE</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; background: #000; overflow: hidden; touch-action: none; user-select: none; font-family: 'Courier New', monospace; }
#c { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

/* HUD */
#hud { position: fixed; inset: 0; pointer-events: none; }

#crosshair {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 18px; height: 18px; z-index: 10;
}
#crosshair::before, #crosshair::after {
  content: ''; position: absolute; background: rgba(0,255,200,0.95);
  box-shadow: 0 0 4px #00ffc8;
}
#crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
#crosshair::after  { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }

#hitmarker {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 40px; height: 40px; opacity: 0; transition: opacity 0.04s; z-index: 10;
}
#hitmarker.show { opacity: 1; }
#hitmarker::before, #hitmarker::after {
  content: ''; position: absolute; width: 14px; height: 2px;
  background: #ff3366; box-shadow: 0 0 6px #ff3366; top: 50%; transform: translateY(-50%);
}
#hitmarker::before { left: 0; }
#hitmarker::after  { right: 0; }

#damage-vignette {
  position: fixed; inset: 0; pointer-events: none; opacity: 0; z-index: 5;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(255,0,50,0.8) 100%);
  transition: opacity 0.07s;
}
#damage-vignette.show { opacity: 1; }

#topbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 10;
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 12px 16px; pointer-events: none;
}
.sbox {
  background: rgba(0,0,0,0.7); border: 1px solid rgba(0,255,200,0.35);
  padding: 4px 11px; color: #00ffc8; font-size: 11px; letter-spacing: 2px;
  text-shadow: 0 0 8px #00ffc8;
}
#wave-lbl { font-size: 12px; color: #fff; letter-spacing: 4px; text-align: center; text-shadow: 0 0 8px #3b82f6; }

#hp-wrap { position: fixed; bottom: 130px; left: 16px; z-index: 10; pointer-events: none; }
.blbl { font-size: 9px; color: rgba(0,255,200,0.65); letter-spacing: 2px; margin-bottom: 3px; }
#hp-bg { width: 110px; height: 5px; background: rgba(255,255,255,0.1); border: 1px solid rgba(0,255,200,0.3); }
#hp-bar { height: 100%; width: 100%; background: linear-gradient(90deg,#00ffc8,#3b82f6); box-shadow: 0 0 6px #00ffc8; transition: width 0.12s; }

#ammo-wrap { position: fixed; bottom: 130px; right: 16px; z-index: 10; text-align: right; pointer-events: none; }
#ammo-n { font-size: 30px; color: #00ffc8; text-shadow: 0 0 10px #00ffc8; line-height: 1; }
#ammo-m { font-size: 12px; color: rgba(255,255,255,0.35); letter-spacing: 2px; }
#reload-t { font-size: 10px; color: #ff9900; letter-spacing: 3px; text-shadow: 0 0 6px #ff9900; animation: blink .4s infinite; display: none; }
@keyframes blink { 50% { opacity: 0; } }

/* Minimap */
#minimap { position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; opacity: 0.7; }

/* Joystick */
#joy-area { position: fixed; bottom: 24px; left: 16px; width: 112px; height: 112px; pointer-events: auto; z-index: 20; }
#joy-base { width: 100%; height: 100%; border-radius: 50%; background: rgba(0,255,200,0.04); border: 1px solid rgba(0,255,200,0.2); }
#joy-knob {
  position: absolute; width: 40px; height: 40px; border-radius: 50%;
  background: rgba(0,255,200,0.22); border: 1px solid #00ffc8; box-shadow: 0 0 10px #00ffc8;
  pointer-events: none; top: 50%; left: 50%; transform: translate(-50%,-50%);
}

/* Fire btn */
#fire-btn {
  position: fixed; bottom: 34px; right: 24px; width: 78px; height: 78px; border-radius: 50%;
  background: rgba(255,51,102,0.1); border: 2px solid rgba(255,51,102,0.5);
  box-shadow: 0 0 18px rgba(255,51,102,0.2);
  display: flex; align-items: center; justify-content: center;
  color: #ff3366; font-size: 10px; letter-spacing: 2px; font-family: 'Courier New',monospace;
  pointer-events: auto; text-shadow: 0 0 6px #ff3366; z-index: 20; cursor: pointer;
}
#fire-btn.on { background: rgba(255,51,102,0.32); box-shadow: 0 0 30px rgba(255,51,102,0.5); }

/* Screens */
.scr {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; z-index: 100; background: rgba(0,0,0,0.9);
}
.scr.off { display: none; }
.scr h1 { font-size: clamp(26px,7vw,50px); letter-spacing: 10px; color: #00ffc8;
  text-shadow: 0 0 25px #00ffc8, 0 0 50px #3b82f6; animation: glow 2s infinite; }
.scr p { color: rgba(255,255,255,0.4); letter-spacing: 4px; font-size: 11px; margin: 12px 0 32px; }
@keyframes glow { 50% { text-shadow: 0 0 45px #00ffc8, 0 0 90px #3b82f6; } }
.btn {
  background: transparent; border: 1px solid #00ffc8; color: #00ffc8;
  padding: 12px 36px; font-family: 'Courier New',monospace; font-size: 12px;
  letter-spacing: 4px; cursor: pointer; box-shadow: 0 0 16px rgba(0,255,200,0.25);
  text-transform: uppercase; margin: 4px;
}
.btn:hover { background: rgba(0,255,200,0.12); }
.btn:active { background: rgba(0,255,200,0.22); }
.rrow { color: #fff; font-size: 12px; letter-spacing: 3px; margin: 4px 0; }
.rrow span { color: #00ffc8; }
.hint { color: rgba(255,255,255,0.25); font-size: 10px; letter-spacing: 3px; text-align: center; line-height: 2.3; margin-top: 16px; }
</style>
</head>
<body>

<!-- DEMO_META
title: NEON STRIKE
desc: スマホ全画面WebGLで動く近未来3DライフルFPS — Wave制サバイバル
tech: Canvas 2D · Raycasting · Touch Controls · First Person Shooter
level: 90
color: #00ffc8
type: game
-->

<canvas id="c"></canvas>

<div id="damage-vignette"></div>
<div id="crosshair"></div>
<div id="hitmarker"></div>

<div id="topbar">
  <div class="sbox">SCORE&nbsp;<span id="el-score">0</span></div>
  <div>
    <div id="wave-lbl">WAVE&nbsp;<span id="el-wave">1</span></div>
    <div class="sbox" style="margin-top:4px;text-align:center">ENEMIES&nbsp;<span id="el-enemies">0</span></div>
  </div>
  <div class="sbox">KILLS&nbsp;<span id="el-kills">0</span></div>
</div>

<div id="hp-wrap">
  <div class="blbl">HP</div>
  <div id="hp-bg"><div id="hp-bar"></div></div>
</div>
<div id="ammo-wrap">
  <div id="ammo-n">30</div>
  <div id="ammo-m">/ 30</div>
  <div id="reload-t">RELOAD</div>
</div>

<canvas id="minimap" width="80" height="80"></canvas>

<div id="joy-area">
  <div id="joy-base"></div>
  <div id="joy-knob"></div>
</div>
<div id="fire-btn">FIRE</div>

<!-- START -->
<div class="scr" id="scr-start">
  <h1>NEON STRIKE</h1>
  <p>NEON CITY WAVE SURVIVAL</p>
  <button class="btn" id="btn-start">START GAME</button>
  <div class="hint">LEFT THUMB: MOVE<br>RIGHT SWIPE: AIM<br>FIRE BUTTON / CLICK: SHOOT<br>R KEY: RELOAD</div>
</div>

<!-- GAME OVER -->
<div class="scr off" id="scr-over">
  <h1 style="color:#ff3366;text-shadow:0 0 25px #ff3366">GAME OVER</h1>
  <div style="margin:16px 0">
    <div class="rrow">WAVE &nbsp;<span id="go-w"></span></div>
    <div class="rrow">KILLS <span id="go-k"></span></div>
    <div class="rrow">SCORE <span id="go-s"></span></div>
  </div>
  <button class="btn" id="btn-retry">RETRY</button>
</div>

<!-- WAVE CLEAR -->
<div class="scr off" id="scr-clear">
  <h1>WAVE CLEAR</h1>
  <p style="color:#ff9900;text-shadow:0 0 8px #ff9900">+30 HP RESTORED</p>
  <button class="btn" id="btn-next">NEXT WAVE</button>
</div>

<script>
(function() {
'use strict';

/* ═══════════════════════════════════════════════════════════
   RAYCASTING ENGINE  (Wolfenstein-style, pure Canvas 2D)
   ═══════════════════════════════════════════════════════════ */

var W = 0, H = 0;         // canvas size (set on resize)
var RW = 320;             // ray resolution width
var RH = 200;             // ray resolution height

var canvas = document.getElementById('c');
var ctx    = canvas.getContext('2d');

// Off-screen buffer at low resolution for performance
var buf    = document.createElement('canvas');
var bctx   = buf.getContext('2d');

function resizeCanvas() {
  W = canvas.width  = window.innerWidth;
  H = canvas.height = window.innerHeight;
  RW = Math.min(320, Math.floor(W / 2));
  RH = Math.min(200, Math.floor(H / 2));
  buf.width  = RW;
  buf.height = RH;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* ── MAP ────────────────────────────────────────────────────
   0 = empty, 1-4 = wall types, 9 = spawn zone              */
var MAP_W = 16, MAP_H = 16;
var MAP = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,2,0,0,3,3,0,0,3,3,0,0,2,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,0,0,3,0,0,0,0,0,0,3,0,0,0,1,
  1,0,2,0,0,3,3,0,0,3,3,0,0,2,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
];

function mapAt(x, y) {
  var mx = Math.floor(x), my = Math.floor(y);
  if (mx < 0 || mx >= MAP_W || my < 0 || my >= MAP_H) return 1;
  return MAP[my * MAP_W + mx];
}

// Wall colors by type (neon palette)
var WALL_COLS = ['','#0d0d2a','#1a1a3e','#0d1a2e','#1a0d1a'];
var WALL_EMIS = ['','#3b82f6','#00ffc8','#3b82f6','#ff3366'];

/* ── PLAYER ─────────────────────────────────────────────── */
var px = 8.5, py = 8.5;    // position
var pa = 0;                  // angle (radians)
var PFOV = Math.PI / 2.8;   // field of view
var PSPEED = 3.5;
var PTURN  = 2.2;

/* ── GAME STATE ─────────────────────────────────────────── */
var state    = 'start';
var wave     = 1;
var kills    = 0;
var score    = 0;
var hp       = 100;
var maxHp    = 100;
var ammo     = 30;
var maxAmmo  = 30;
var reloading = false;
var lastFire  = 0;
var FIRE_RATE = 130;
var RELOAD_MS = 1700;
var moveX = 0, moveZ = 0;
var lookDelta = 0;
var autoTimer = null;
var enemies = [];
var particles = [];
var keys = {};

/* ── GUN ANIMATION ──────────────────────────────────────── */
var gunKick   = 0;
var gunSway   = 0;
var muzzleOn  = false;

/* ── ENEMY SPAWN POINTS ─────────────────────────────────── */
var SPAWNS = [
  [1.5,1.5],[14.5,1.5],[1.5,14.5],[14.5,14.5],
  [8,1.5],[1.5,8],[14.5,8],[8,14.5],
  [3,3],[13,3],[3,13],[13,13],
  [8,4],[4,8],[12,8],[8,12]
];

/* ── RAYCASTING ─────────────────────────────────────────── */
var zbuf = []; // z-buffer for sprite clipping

function castRays() {
  zbuf = [];
  var halfH = RH / 2;

  for (var x = 0; x < RW; x++) {
    // Ray direction
    var camX = (2 * x / RW) - 1;
    var rayDirX = Math.cos(pa) - Math.sin(pa) * camX * (PFOV / (Math.PI / 4));
    var rayDirY = Math.sin(pa) + Math.cos(pa) * camX * (PFOV / (Math.PI / 4));

    var mapX = Math.floor(px), mapY = Math.floor(py);
    var deltaX = Math.abs(1 / rayDirX);
    var deltaY = Math.abs(1 / rayDirY);
    var stepX, stepY, sideDistX, sideDistY;

    if (rayDirX < 0) { stepX = -1; sideDistX = (px - mapX) * deltaX; }
    else             { stepX =  1; sideDistX = (mapX + 1 - px) * deltaX; }
    if (rayDirY < 0) { stepY = -1; sideDistY = (py - mapY) * deltaY; }
    else             { stepY =  1; sideDistY = (mapY + 1 - py) * deltaY; }

    var hit = 0, side = 0, wallType = 0;
    var maxSteps = 32;
    while (!hit && maxSteps-- > 0) {
      if (sideDistX < sideDistY) { sideDistX += deltaX; mapX += stepX; side = 0; }
      else                        { sideDistY += deltaY; mapY += stepY; side = 1; }
      wallType = mapAt(mapX, mapY);
      if (wallType > 0) hit = 1;
    }

    var wallDist = side === 0
      ? (mapX - px + (1 - stepX) / 2) / rayDirX
      : (mapY - py + (1 - stepY) / 2) / rayDirY;

    wallDist = Math.max(0.01, wallDist);
    zbuf[x] = wallDist;

    var lineH  = Math.floor(RH / wallDist);
    var drawS  = Math.max(0, halfH - lineH / 2);
    var drawE  = Math.min(RH - 1, halfH + lineH / 2);

    // Wall color with distance fog
    var fog   = Math.min(1, wallDist / 12);
    var wtype = Math.min(4, wallType);
    var base  = WALL_COLS[wtype] || '#0d0d2a';
    var emis  = WALL_EMIS[wtype] || '#3b82f6';

    // Darker on side faces
    var shade = side === 1 ? 0.6 : 1.0;
    shade *= (1 - fog * 0.85);

    bctx.fillStyle = lerpColor(base, '#050510', fog * 0.9);
    bctx.fillRect(x, drawS, 1, drawE - drawS);

    // Emissive neon edge line (top/bottom of wall strip)
    if (lineH > 2 && shade > 0.3) {
      bctx.fillStyle = emis;
      bctx.globalAlpha = shade * 0.35 * (1 - fog);
      bctx.fillRect(x, drawS, 1, 1);
      bctx.fillRect(x, drawE - 1, 1, 1);
      bctx.globalAlpha = 1;
    }
  }
}

function lerpColor(a, b, t) {
  // Simple hex lerp
  var ar = parseInt(a.slice(1,3),16), ag = parseInt(a.slice(3,5),16), ab2 = parseInt(a.slice(5,7),16);
  var br = parseInt(b.slice(1,3),16), bg = parseInt(b.slice(3,5),16), bb2 = parseInt(b.slice(5,7),16);
  var r = Math.round(ar + (br - ar) * t);
  var g = Math.round(ag + (bg - ag) * t);
  var b2= Math.round(ab2 + (bb2 - ab2) * t);
  return 'rgb('+r+','+g+','+b2+')';
}

function drawFloorCeiling() {
  // Ceiling gradient
  var cg = bctx.createLinearGradient(0, 0, 0, RH / 2);
  cg.addColorStop(0, '#050510');
  cg.addColorStop(1, '#0a0a1f');
  bctx.fillStyle = cg;
  bctx.fillRect(0, 0, RW, RH / 2);

  // Floor gradient
  var fg = bctx.createLinearGradient(0, RH / 2, 0, RH);
  fg.addColorStop(0, '#080815');
  fg.addColorStop(1, '#020208');
  bctx.fillStyle = fg;
  bctx.fillRect(0, RH / 2, RW, RH / 2);

  // Neon grid on floor
  bctx.strokeStyle = 'rgba(0,255,200,0.06)';
  bctx.lineWidth = 0.5;
  for (var gx = 0; gx < RW; gx += Math.floor(RW / 16)) {
    bctx.beginPath(); bctx.moveTo(gx, RH / 2); bctx.lineTo(RW / 2, RH); bctx.stroke();
  }
}

/* ── ENEMY SPRITES ──────────────────────────────────────── */
function drawSprites() {
  // Sort enemies by distance (far to near)
  var sorted = [];
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    var dx = e.x - px, dy = e.y - py;
    sorted.push({ e: e, dist2: dx*dx + dy*dy });
  }
  sorted.sort(function(a, b) { return b.dist2 - a.dist2; });

  for (var si = 0; si < sorted.length; si++) {
    var e = sorted[si].e;
    var sprDist = Math.sqrt(sorted[si].dist2);
    if (sprDist < 0.3) continue;

    // Transform sprite to camera space
    var dx = e.x - px;
    var dy = e.y - py;
    var invDet = 1 / (Math.cos(pa) * Math.sin(pa) - Math.sin(pa) * Math.cos(pa));
    // Use angle to sprite
    var relAngle = Math.atan2(dy, dx) - pa;
    // Normalize to [-PI, PI]
    while (relAngle >  Math.PI) relAngle -= 2 * Math.PI;
    while (relAngle < -Math.PI) relAngle += 2 * Math.PI;

    // Only draw if in FOV
    if (Math.abs(relAngle) > PFOV * 0.7) continue;

    var screenX = Math.floor((0.5 + relAngle / PFOV) * RW);
    var sprH    = Math.abs(Math.floor(RH / sprDist));
    var sprW    = sprH * 0.65;
    var drawX   = Math.floor(screenX - sprW / 2);
    var drawY   = Math.floor(RH / 2 - sprH / 2);

    // Fog
    var fog = Math.min(1, sprDist / 10);
    var alpha = Math.max(0, 1 - fog * 0.9);
    if (alpha < 0.05) continue;

    bctx.globalAlpha = alpha;

    // Body
    var bodyColor = e.flashTimer > 0 ? '#ffffff' : (e.alive ? '#cc1133' : '#440011');
    bctx.fillStyle = bodyColor;
    bctx.fillRect(drawX + sprW*0.2, drawY + sprH*0.35, sprW*0.6, sprH*0.55);

    // Head
    var headColor = e.flashTimer > 0 ? '#ffffff' : (e.alive ? '#dd2244' : '#330011');
    bctx.fillStyle = headColor;
    var hSize = sprW * 0.4;
    bctx.fillRect(drawX + sprW*0.3, drawY + sprH*0.1, hSize, hSize);

    // Eyes (neon red)
    if (e.alive && alpha > 0.4) {
      bctx.fillStyle = '#ff0000';
      bctx.globalAlpha = alpha * 0.9;
      var es = Math.max(1, sprW * 0.08);
      bctx.fillRect(drawX + sprW*0.33, drawY + sprH*0.18, es, es);
      bctx.fillRect(drawX + sprW*0.55, drawY + sprH*0.18, es, es);
    }

    // HP bar above head
    if (e.alive && sprH > 20) {
      var hpRatio = e.hp / e.maxHp;
      bctx.globalAlpha = alpha * 0.8;
      bctx.fillStyle = '#330000';
      bctx.fillRect(drawX, drawY - 4, sprW, 3);
      bctx.fillStyle = hpRatio > 0.5 ? '#00ff88' : '#ff3366';
      bctx.fillRect(drawX, drawY - 4, sprW * hpRatio, 3);
    }

    bctx.globalAlpha = 1;
  }
}

/* ── GUN DRAW ───────────────────────────────────────────── */
function drawGun(t) {
  var sw = RW, sh = RH;
  var gw = sw * 0.35, gh = gw * 0.55;
  var gx = sw / 2 - gw / 2 + Math.sin(t * 3) * 2 * Math.max(0.1, Math.abs(moveZ) + Math.abs(moveX));
  var gy = sh - gh + gunKick * 18 + Math.abs(Math.sin(t * 3)) * 2;

  // Shadow
  bctx.fillStyle = 'rgba(0,0,0,0.5)';
  bctx.fillRect(gx + 3, gy + 3, gw, gh);

  // Body
  bctx.fillStyle = '#1a1a2e';
  bctx.fillRect(gx, gy, gw, gh);

  // Neon accent stripe
  bctx.fillStyle = '#00ffc8';
  bctx.fillRect(gx, gy + 2, gw, 2);
  bctx.fillRect(gx, gy + gh - 4, gw, 2);

  // Barrel
  bctx.fillStyle = '#111122';
  bctx.fillRect(gx + gw * 0.42, gy - gh * 0.3, gw * 0.16, gh * 0.35);
  bctx.fillStyle = '#00ffc8';
  bctx.fillRect(gx + gw * 0.42, gy - gh * 0.3, gw * 0.16, 2);

  // Muzzle flash
  if (muzzleOn) {
    bctx.fillStyle = '#ffcc00';
    bctx.globalAlpha = 0.9;
    var mfx = gx + gw * 0.42 + gw * 0.08;
    var mfy = gy - gh * 0.3 - 6;
    bctx.beginPath();
    bctx.arc(mfx, mfy, 6, 0, Math.PI * 2);
    bctx.fill();
    bctx.fillStyle = '#ffffff';
    bctx.globalAlpha = 0.7;
    bctx.beginPath();
    bctx.arc(mfx, mfy, 3, 0, Math.PI * 2);
    bctx.fill();
    bctx.globalAlpha = 1;
  }
}

/* ── RENDER ─────────────────────────────────────────────── */
function render(t) {
  bctx.clearRect(0, 0, RW, RH);
  drawFloorCeiling();
  castRays();
  drawSprites();
  drawGun(t);

  // Blit low-res buffer to full canvas
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(buf, 0, 0, W, H);

  // Scan-line overlay for CRT feel
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  for (var y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }
}

/* ── MINIMAP ────────────────────────────────────────────── */
var mmCanvas = document.getElementById('minimap');
var mmCtx    = mmCanvas.getContext('2d');
var MM = 80, CELL = MM / MAP_W;

function drawMinimap() {
  mmCtx.clearRect(0, 0, MM, MM);
  mmCtx.fillStyle = 'rgba(0,0,0,0.6)';
  mmCtx.fillRect(0, 0, MM, MM);

  for (var my = 0; my < MAP_H; my++) {
    for (var mx = 0; mx < MAP_W; mx++) {
      var t = MAP[my * MAP_W + mx];
      if (t > 0) {
        mmCtx.fillStyle = WALL_EMIS[Math.min(t, 4)] || '#3b82f6';
        mmCtx.globalAlpha = 0.5;
        mmCtx.fillRect(mx * CELL, my * CELL, CELL - 0.5, CELL - 0.5);
        mmCtx.globalAlpha = 1;
      }
    }
  }

  // Enemies
  for (var ei = 0; ei < enemies.length; ei++) {
    var e = enemies[ei];
    if (!e.alive) continue;
    mmCtx.fillStyle = '#ff3366';
    mmCtx.beginPath();
    mmCtx.arc(e.x * CELL, e.y * CELL, CELL * 0.4, 0, Math.PI * 2);
    mmCtx.fill();
  }

  // Player
  mmCtx.fillStyle = '#00ffc8';
  mmCtx.beginPath();
  mmCtx.arc(px * CELL, py * CELL, CELL * 0.55, 0, Math.PI * 2);
  mmCtx.fill();
  // Direction
  mmCtx.strokeStyle = '#00ffc8';
  mmCtx.lineWidth = 1;
  mmCtx.beginPath();
  mmCtx.moveTo(px * CELL, py * CELL);
  mmCtx.lineTo((px + Math.cos(pa) * 1.2) * CELL, (py + Math.sin(pa) * 1.2) * CELL);
  mmCtx.stroke();
}

/* ── ENEMY AI ───────────────────────────────────────────── */
var SIGHT = 8, ATRANGE = 6, STOP = 0.8;

function spawnWave(w) {
  enemies = [];
  var count = 3 + w * 2;
  for (var i = 0; i < count; i++) {
    var sp = SPAWNS[i % SPAWNS.length];
    var baseHp = 35 + (w - 1) * 12;
    enemies.push({
      x: sp[0] + (Math.random() - 0.5) * 0.6,
      y: sp[1] + (Math.random() - 0.5) * 0.6,
      hp: baseHp, maxHp: baseHp,
      speed: 1.4 + Math.random() * 0.5 + (w - 1) * 0.2,
      fireTimer: 1 + Math.random() * 2,
      fireCd: Math.max(0.7, 2.5 - w * 0.12),
      patAngle: Math.random() * Math.PI * 2,
      state: 'patrol',
      flashTimer: 0,
      alive: true
    });
  }
  setEl('el-enemies', enemies.length);
}

function updateEnemies(dt) {
  var alive = 0;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    alive++;
    if (e.flashTimer > 0) e.flashTimer -= dt;

    var dx = px - e.x, dy = py - e.y;
    var dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < SIGHT) e.state = 'chase';

    if (e.state === 'chase') {
      if (dist > STOP && dist > 0.01) {
        var spd = e.speed * dt;
        var nx = e.x + dx / dist * spd;
        var ny = e.y + dy / dist * spd;
        if (!mapAt(nx, e.y)) e.x = nx;
        if (!mapAt(e.x, ny)) e.y = ny;
      }
      if (dist < ATRANGE) {
        e.fireTimer -= dt;
        if (e.fireTimer <= 0) {
          e.fireTimer = e.fireCd;
          enemyShoot(dist);
        }
      }
    } else {
      // Patrol
      e.patAngle += dt * 0.8;
      var nx2 = e.x + Math.cos(e.patAngle) * 0.03;
      var ny2 = e.y + Math.sin(e.patAngle) * 0.03;
      if (!mapAt(nx2, e.y)) e.x = nx2;
      if (!mapAt(e.x, ny2)) e.y = ny2;
    }
  }
  setEl('el-enemies', alive);
  if (alive === 0 && state === 'playing') waveClear();
}

function enemyShoot(dist) {
  var hit = 0.22 + (1 - dist / ATRANGE) * 0.28;
  if (Math.random() > hit) return;
  hp -= 10;
  if (hp < 0) hp = 0;
  document.getElementById('hp-bar').style.width = (hp / maxHp * 100) + '%';
  flashDmg();
  if (hp <= 0) playerDead();
}

/* ── SHOOTING ───────────────────────────────────────────── */
function shoot() {
  if (state !== 'playing') return;
  if (reloading || ammo <= 0) { if (!reloading && ammo <= 0) startReload(); return; }
  var now = performance.now();
  if (now - lastFire < FIRE_RATE) return;
  lastFire = now;

  ammo--;
  setEl('ammo-n', ammo);
  if (ammo <= 0) startReload();

  gunKick = 1;
  muzzleOn = true;
  setTimeout(function() { muzzleOn = false; }, 55);

  // Shake canvas
  canvas.style.transform = 'translate('+(Math.random()*5-2.5)+'px,'+(Math.random()*5-2.5)+'px)';
  setTimeout(function() { canvas.style.transform = ''; }, 80);

  // Ray-based hit detection: check if any enemy is in center of screen
  var hitDist = 99;
  var hitEnemy = null;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    var dx = e.x - px, dy = e.y - py;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var angleToEnemy = Math.atan2(dy, dx);
    var relAngle = angleToEnemy - pa;
    while (relAngle >  Math.PI) relAngle -= 2 * Math.PI;
    while (relAngle < -Math.PI) relAngle += 2 * Math.PI;
    // Hit cone
    var hitCone = 0.08 + 0.04 / Math.max(0.5, dist);
    if (Math.abs(relAngle) < hitCone && dist < hitDist && dist < 14) {
      // Check wall not blocking
      if (zbuf[Math.floor(RW / 2)] > dist - 0.5) {
        hitDist = dist; hitEnemy = e;
      }
    }
  }

  if (hitEnemy) {
    // Headshot if aiming high
    var dmg = 38;
    hitEnemy.hp -= dmg;
    hitEnemy.flashTimer = 0.1;
    showHit();
    spawnParticles(hitEnemy.x, hitEnemy.y);
    if (hitEnemy.hp <= 0) killEnemy(hitEnemy);
  }
}

function killEnemy(e) {
  e.alive = false;
  kills++; score += 100 * wave;
  setEl('el-kills', kills);
  setEl('el-score', score);
}

function startReload() {
  if (reloading || ammo >= maxAmmo) return;
  reloading = true;
  document.getElementById('reload-t').style.display = 'block';
  setTimeout(function() {
    ammo = maxAmmo; reloading = false;
    document.getElementById('reload-t').style.display = 'none';
    setEl('ammo-n', ammo);
  }, RELOAD_MS);
}

/* ── PARTICLES ──────────────────────────────────────────── */
function spawnParticles(ex, ey) {
  for (var i = 0; i < 5; i++) {
    particles.push({
      x: ex, y: ey,
      vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2,
      life: 0.4
    });
  }
}

function updateParticles(dt) {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

/* ── PLAYER MOVEMENT ────────────────────────────────────── */
function updatePlayer(dt) {
  if (state !== 'playing') return;

  // Rotate
  pa += lookDelta * PTURN * dt;
  lookDelta = 0;

  // Move
  var fx = Math.cos(pa) * (-moveZ) - Math.sin(pa) * moveX;
  var fy = Math.sin(pa) * (-moveZ) + Math.cos(pa) * moveX;
  var spd = PSPEED * dt;
  var nx = px + fx * spd;
  var ny = py + fy * spd;

  if (!mapAt(nx + Math.sign(fx) * 0.2, py)) px = Math.max(0.5, Math.min(MAP_W - 0.5, nx));
  if (!mapAt(px, ny + Math.sign(fy) * 0.2)) py = Math.max(0.5, Math.min(MAP_H - 0.5, ny));

  // Gun sway / kick recovery
  if (gunKick > 0) gunKick -= dt * 6;
  if (gunKick < 0) gunKick = 0;
}

/* ── EFFECTS ────────────────────────────────────────────── */
var hitT;
function showHit() {
  var h = document.getElementById('hitmarker');
  h.classList.add('show');
  clearTimeout(hitT);
  hitT = setTimeout(function() { h.classList.remove('show'); }, 130);
}

function flashDmg() {
  var v = document.getElementById('damage-vignette');
  v.classList.add('show');
  setTimeout(function() { v.classList.remove('show'); }, 260);
}

/* ── GAME FLOW ──────────────────────────────────────────── */
function startGame() {
  state = 'playing'; wave = 1; kills = 0; score = 0;
  hp = maxHp; ammo = maxAmmo; reloading = false;
  px = 8.5; py = 8.5; pa = 0;
  moveX = 0; moveZ = 0;
  particles = [];

  setEl('el-kills', 0); setEl('el-score', 0); setEl('el-wave', 1);
  setEl('ammo-n', maxAmmo);
  document.getElementById('hp-bar').style.width = '100%';
  document.getElementById('reload-t').style.display = 'none';
  hide('scr-start'); hide('scr-over'); hide('scr-clear');

  spawnWave(wave);
}

function waveClear() {
  if (state !== 'playing') return;
  state = 'waveclear';
  show('scr-clear');
}

function nextWave() {
  wave++;
  hp = Math.min(maxHp, hp + 30);
  ammo = maxAmmo; reloading = false;
  document.getElementById('hp-bar').style.width = (hp / maxHp * 100) + '%';
  setEl('ammo-n', ammo);
  document.getElementById('reload-t').style.display = 'none';
  setEl('el-wave', wave);
  hide('scr-clear');
  particles = [];
  state = 'playing';
  spawnWave(wave);
}

function playerDead() {
  if (state !== 'playing') return;
  state = 'dead'; stopAuto();
  document.getElementById('go-w').textContent = wave;
  document.getElementById('go-k').textContent = kills;
  document.getElementById('go-s').textContent = score;
  show('scr-over');
}

function startAuto() {
  if (autoTimer) return;
  shoot();
  autoTimer = setInterval(shoot, FIRE_RATE);
}
function stopAuto() {
  if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
}

/* ── TOUCH ──────────────────────────────────────────────── */
var joyArea = document.getElementById('joy-area');
var joyKnob = document.getElementById('joy-knob');
var fireBtn = document.getElementById('fire-btn');
var JR = 44;
var joyId = -1, lookId = -1, fireId = -1;
var joyBX = 0, joyBY = 0, lookPX = 0, lookPY = 0;

document.addEventListener('touchstart', function(e) {
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    var tx = t.clientX, ty = t.clientY;
    var jr = joyArea.getBoundingClientRect();
    var fr = fireBtn.getBoundingClientRect();
    if (tx >= jr.left && tx <= jr.right && ty >= jr.top && ty <= jr.bottom) {
      joyId = t.identifier;
      joyBX = jr.left + jr.width / 2; joyBY = jr.top + jr.height / 2;
    } else if (tx >= fr.left && tx <= fr.right && ty >= fr.top && ty <= fr.bottom) {
      fireId = t.identifier; fireBtn.classList.add('on'); startAuto();
    } else if (lookId === -1) {
      lookId = t.identifier; lookPX = tx; lookPY = ty;
    }
  }
}, { passive: false });

document.addEventListener('touchmove', function(e) {
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    if (t.identifier === joyId) {
      var dx = t.clientX - joyBX, dy = t.clientY - joyBY;
      var len = Math.sqrt(dx*dx+dy*dy);
      if (len > JR) { dx=dx/len*JR; dy=dy/len*JR; }
      joyKnob.style.left = (50 + dx/JR*50) + '%';
      joyKnob.style.top  = (50 + dy/JR*50) + '%';
      moveX = dx/JR; moveZ = dy/JR;
    } else if (t.identifier === lookId) {
      lookDelta += (t.clientX - lookPX) / W * 5;
      lookPX = t.clientX; lookPY = t.clientY;
    }
  }
}, { passive: false });

document.addEventListener('touchend', function(e) {
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    if (t.identifier === joyId) { joyId=-1; moveX=0; moveZ=0; joyKnob.style.left='50%'; joyKnob.style.top='50%'; }
    else if (t.identifier === lookId) { lookId=-1; }
    else if (t.identifier === fireId) { fireId=-1; fireBtn.classList.remove('on'); stopAuto(); }
  }
}, { passive: false });

/* ── DESKTOP ────────────────────────────────────────────── */
canvas.addEventListener('mousedown', function(e) {
  if (e.button === 0) { canvas.requestPointerLock(); startAuto(); }
});
document.addEventListener('mouseup', stopAuto);
document.addEventListener('mousemove', function(e) {
  if (document.pointerLockElement !== canvas) return;
  lookDelta += e.movementX / W * 5;
});

fireBtn.addEventListener('mousedown', function(e) { e.stopPropagation(); startAuto(); fireBtn.classList.add('on'); });
fireBtn.addEventListener('mouseup',   function()  { stopAuto(); fireBtn.classList.remove('on'); });

document.addEventListener('keydown', function(e) {
  keys[e.code] = true;
  if (e.code === 'KeyR') startReload();
});
document.addEventListener('keyup', function(e) { keys[e.code] = false; });

function processKeys() {
  var s = 0.9;
  moveZ = (keys['KeyW'] ? -s : 0) + (keys['KeyS'] ? s : 0);
  moveX = (keys['KeyA'] ? -s : 0) + (keys['KeyD'] ? s : 0);
  if (keys['ArrowLeft'])  lookDelta -= 0.05;
  if (keys['ArrowRight']) lookDelta += 0.05;
  if (keys['Space'] && !autoTimer) startAuto();
  if (!keys['Space']) {} // mouseup handles stop
}

/* ── BUTTONS ────────────────────────────────────────────── */
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-retry').addEventListener('click', startGame);
document.getElementById('btn-next').addEventListener('click', nextWave);

/* ── HELPERS ────────────────────────────────────────────── */
function setEl(id, val) { document.getElementById(id).textContent = val; }
function show(id) { document.getElementById(id).classList.remove('off'); }
function hide(id) { document.getElementById(id).classList.add('off'); }

/* ── MAIN LOOP ──────────────────────────────────────────── */
var lastTime = performance.now();

function loop(now) {
  requestAnimationFrame(loop);
  var dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  if (state === 'playing') {
    processKeys();
    updatePlayer(dt);
    updateEnemies(dt);
    updateParticles(dt);
  }

  render(now / 1000);
  drawMinimap();
}

requestAnimationFrame(loop);

}());
</script>
</body>
</html>