<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EVOLUTION SIMULATOR - Genetic Algorithm Lab</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Orbitron:wght@700;900&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-primary: #0a0e27;
  --bg-secondary: #111736;
  --bg-tertiary: #1a2045;
  --accent-cyan: #00fff9;
  --accent-magenta: #ff006e;
  --accent-yellow: #ffbe0b;
  --text-primary: #e8f4f8;
  --text-secondary: #8892b0;
  --grid-color: rgba(0, 255, 249, 0.1);
  --danger: #ef476f;
  --success: #06ffa5;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  overflow-x: hidden;
  line-height: 1.6;
}

.container {
  max-width: 1920px;
  margin: 0 auto;
  padding: 20px;
}

/* Header */
header {
  text-align: center;
  padding: 40px 20px;
  background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
  border-bottom: 2px solid var(--accent-cyan);
  position: relative;
  overflow: hidden;
}

header::before {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    repeating-linear-gradient(0deg, transparent, transparent 2px, var(--grid-color) 2px, var(--grid-color) 4px),
    repeating-linear-gradient(90deg, transparent, transparent 2px, var(--grid-color) 2px, var(--grid-color) 4px);
  pointer-events: none;
  animation: gridScroll 20s linear infinite;
}

@keyframes gridScroll {
  from { transform: translate(0, 0); }
  to { transform: translate(40px, 40px); }
}

h1 {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(2rem, 5vw, 4rem);
  font-weight: 900;
  letter-spacing: 0.05em;
  background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-magenta) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 10px;
  position: relative;
  animation: glowPulse 3s ease-in-out infinite;
}

@keyframes glowPulse {
  0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 249, 0.5)); }
  50% { filter: drop-shadow(0 0 40px rgba(0, 255, 249, 0.8)); }
}

.subtitle {
  font-size: 1rem;
  color: var(--text-secondary);
  letter-spacing: 0.3em;
  text-transform: uppercase;
  position: relative;
}

/* Grid Layout */
.dashboard {
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  gap: 20px;
  margin-top: 30px;
}

@media (max-width: 1400px) {
  .dashboard {
    grid-template-columns: 1fr 2fr;
  }
  .stats-right {
    grid-column: 1 / -1;
  }
}

@media (max-width: 900px) {
  .dashboard {
    grid-template-columns: 1fr;
  }
}

/* Panel */
.panel {
  background: var(--bg-secondary);
  border: 1px solid var(--grid-color);
  border-radius: 8px;
  padding: 20px;
  position: relative;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.panel-header {
  font-family: 'Orbitron', sans-serif;
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--accent-cyan);
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--grid-color);
  letter-spacing: 0.05em;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.panel-header:hover {
  color: var(--accent-magenta);
}

.panel-header::after {
  content: '‚ñº';
  font-size: 0.8rem;
  transition: transform 0.3s ease;
}

.panel-header.collapsed::after {
  transform: rotate(-90deg);
}

.panel-content {
  max-height: 2000px;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  opacity: 1;
}

.panel-content.collapsed {
  max-height: 0;
  opacity: 0;
}

/* Canvas */
#simulationCanvas {
  width: 100%;
  height: 600px;
  background: var(--bg-tertiary);
  border: 2px solid var(--accent-cyan);
  border-radius: 4px;
  display: block;
  box-shadow: inset 0 0 30px rgba(0, 255, 249, 0.1);
}

/* Controls */
.controls {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 10px;
  margin-top: 15px;
}

.btn {
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--accent-cyan) 0%, #00ccc4 100%);
  border: none;
  color: var(--bg-primary);
  font-family: 'JetBrains Mono', monospace;
  font-weight: 700;
  font-size: 0.85rem;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 100%);
  transform: translateX(-100%);
  transition: transform 0.3s ease;
}

.btn:hover::before {
  transform: translateX(0);
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 20px rgba(0, 255, 249, 0.4);
}

.btn:active {
  transform: translateY(0);
}

.btn-danger {
  background: linear-gradient(135deg, var(--danger) 0%, #cc2356 100%);
}

.btn-success {
  background: linear-gradient(135deg, var(--success) 0%, #05cc88 100%);
}

/* Stats */
.stat-grid {
  display: grid;
  gap: 15px;
}

.stat-item {
  background: var(--bg-tertiary);
  padding: 15px;
  border-radius: 4px;
  border-left: 3px solid var(--accent-cyan);
  transition: all 0.3s ease;
}

.stat-item:hover {
  border-left-color: var(--accent-magenta);
  transform: translateX(5px);
}

.stat-label {
  font-size: 0.75rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 5px;
}

.stat-value {
  font-size: 1.8rem;
  font-weight: 700;
  color: var(--accent-cyan);
  font-family: 'Orbitron', sans-serif;
}

.stat-value.success {
  color: var(--success);
}

.stat-value.danger {
  color: var(--danger);
}

/* Progress Bar */
.progress-container {
  margin-top: 15px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-cyan) 0%, var(--accent-magenta) 100%);
  transition: width 0.3s ease;
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  from { transform: translateX(-100%); }
  to { transform: translateX(100%); }
}

/* Graph */
#fitnessGraph {
  width: 100%;
  height: 200px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  margin-top: 15px;
}

/* Settings */
.setting-item {
  margin-bottom: 15px;
}

.setting-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 0.85rem;
}

.setting-value {
  color: var(--accent-yellow);
  font-weight: 700;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  background: var(--bg-tertiary);
  border-radius: 3px;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--accent-cyan);
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
}

input[type="range"]::-webkit-slider-thumb:hover {
  background: var(--accent-magenta);
  transform: scale(1.2);
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--accent-cyan);
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

/* Status Badge */
.status-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.status-badge.running {
  background: var(--success);
  color: var(--bg-primary);
  animation: pulse 2s ease-in-out infinite;
}

.status-badge.paused {
  background: var(--accent-yellow);
  color: var(--bg-primary);
}

.status-badge.stopped {
  background: var(--danger);
  color: var(--bg-primary);
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Console Log */
.console-log {
  background: var(--bg-primary);
  border: 1px solid var(--grid-color);
  border-radius: 4px;
  padding: 15px;
  height: 150px;
  overflow-y: auto;
  font-size: 0.75rem;
  margin-top: 15px;
  font-family: 'JetBrains Mono', monospace;
}

.console-log::-webkit-scrollbar {
  width: 8px;
}

.console-log::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

.console-log::-webkit-scrollbar-thumb {
  background: var(--accent-cyan);
  border-radius: 4px;
}

.log-entry {
  margin-bottom: 5px;
  opacity: 0;
  animation: fadeIn 0.3s ease forwards;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

.log-timestamp {
  color: var(--text-secondary);
}

.log-info { color: var(--accent-cyan); }
.log-success { color: var(--success); }
.log-warning { color: var(--accent-yellow); }
.log-error { color: var(--danger); }

/* Creature Info */
.creature-preview {
  margin-top: 15px;
  padding: 15px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  border: 1px solid var(--grid-color);
}

.neural-network-viz {
  margin-top: 10px;
  padding: 10px;
  background: var(--bg-primary);
  border-radius: 4px;
  text-align: center;
  font-size: 0.7rem;
  color: var(--text-secondary);
}

/* Loading Animation */
.loading {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(10, 14, 39, 0.95);
  z-index: 9999;
  justify-content: center;
  align-items: center;
}

.loading.active {
  display: flex;
}

.loading-content {
  text-align: center;
}

.spinner {
  width: 60px;
  height: 60px;
  border: 4px solid var(--bg-tertiary);
  border-top: 4px solid var(--accent-cyan);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>
</head>
<body>

<!-- DEMO_META
title: EVOLUTION SIMULATOR - Genetic Algorithm Lab
desc: ÈÅ∫‰ºùÁöÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†+„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅßÁîüÁâ©„ÅåÈÄ≤Âåñ„Åô„ÇãÊßòÂ≠ê„Çí„É™„Ç¢„É´„Çø„Ç§„É†ÂèØË¶ñÂåñ
tech: Genetic Algorithm ¬∑ Neural Network ¬∑ Real-time Evolution ¬∑ Production Architecture
level: 99
color: #00fff9
type: simulation
-->

<div class="loading" id="loading">
  <div class="loading-content">
    <div class="spinner"></div>
    <div>Initializing Evolution Engine...</div>
  </div>
</div>

<header>
  <h1>EVOLUTION SIMULATOR</h1>
  <div class="subtitle">Genetic Algorithm Laboratory</div>
</header>

<div class="container">
  <div class="dashboard">
    <!-- Left Panel: Stats & Controls -->
    <div class="stats-left">
      <div class="panel">
        <div class="panel-header" onclick="togglePanel(this)">STATUS</div>
        <div class="panel-content">
          <div class="stat-grid">
            <div class="stat-item">
              <div class="stat-label">Generation</div>
              <div class="stat-value" id="generation">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Population</div>
              <div class="stat-value success" id="population">50</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Alive</div>
              <div class="stat-value" id="alive">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Best Fitness</div>
              <div class="stat-value success" id="bestFitness">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Avg Fitness</div>
              <div class="stat-value" id="avgFitness">0</div>
            </div>
          </div>
          
          <div class="progress-container">
            <div class="stat-label">Generation Progress</div>
            <div class="progress-bar">
              <div class="progress-fill" id="genProgress" style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top: 20px;">
        <div class="panel-header" onclick="togglePanel(this)">CONTROLS</div>
        <div class="panel-content">
          <div class="controls">
            <button class="btn btn-success" id="startBtn">START</button>
            <button class="btn" id="pauseBtn">PAUSE</button>
            <button class="btn btn-danger" id="resetBtn">RESET</button>
            <button class="btn" id="speedBtn">SPEED: 1x</button>
          </div>
          <div style="margin-top: 15px; text-align: center;">
            <span class="status-badge stopped" id="statusBadge">STOPPED</span>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top: 20px;">
        <div class="panel-header collapsed" onclick="togglePanel(this)">SETTINGS</div>
        <div class="panel-content collapsed">
          <div class="setting-item">
            <div class="setting-label">
              <span>Population Size</span>
              <span class="setting-value" id="popSizeValue">50</span>
            </div>
            <input type="range" id="popSize" min="20" max="100" value="50" step="10">
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span>Mutation Rate</span>
              <span class="setting-value" id="mutRateValue">0.1</span>
            </div>
            <input type="range" id="mutRate" min="0.01" max="0.5" value="0.1" step="0.01">
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span>Generation Time</span>
              <span class="setting-value" id="genTimeValue">10s</span>
            </div>
            <input type="range" id="genTime" min="5" max="30" value="10" step="5">
          </div>
        </div>
      </div>
      
      <div class="panel" style="margin-top: 20px;">
        <div class="panel-header collapsed" onclick="togglePanel(this)">HOW TO PLAY</div>
        <div class="panel-content collapsed">
          <div style="font-size: 0.85rem; line-height: 1.6;">
            <p style="margin-bottom: 10px;"><strong>üéØ Goal:</strong> Watch creatures evolve to collect food efficiently</p>
            <p style="margin-bottom: 10px;"><strong>üß¨ Evolution:</strong> Each generation, the best performers reproduce</p>
            <p style="margin-bottom: 10px;"><strong>üìä Metrics:</strong></p>
            <ul style="margin-left: 20px; margin-bottom: 10px;">
              <li>Food collected = Primary fitness</li>
              <li>Distance traveled = Exploration</li>
              <li>Survival time = Longevity</li>
            </ul>
            <p style="margin-bottom: 10px;"><strong>‚öôÔ∏è Controls:</strong></p>
            <ul style="margin-left: 20px;">
              <li>START - Begin simulation</li>
              <li>PAUSE - Pause/Resume</li>
              <li>RESET - Start over</li>
              <li>SPEED - 1x/2x/4x speed</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Center Panel: Simulation -->
    <div class="center-panel">
      <div class="panel">
        <div class="panel-header" onclick="togglePanel(this)">SIMULATION</div>
        <div class="panel-content">
          <canvas id="simulationCanvas"></canvas>
        </div>
      </div>

      <div class="panel" style="margin-top: 20px;">
        <div class="panel-header" onclick="togglePanel(this)">FITNESS EVOLUTION</div>
        <div class="panel-content">
          <canvas id="fitnessGraph"></canvas>
        </div>
      </div>
    </div>

    <!-- Right Panel: Analysis -->
    <div class="stats-right">
      <div class="panel">
        <div class="panel-header" onclick="togglePanel(this)">BEST CREATURE</div>
        <div class="panel-content">
          <div class="creature-preview">
            <div class="stat-label">Genome Length</div>
            <div class="stat-value" id="genomeLength" style="font-size: 1.2rem;">0</div>
            
            <div class="stat-label" style="margin-top: 15px;">Distance Traveled</div>
            <div class="stat-value" id="distTraveled" style="font-size: 1.2rem;">0m</div>
            
            <div class="stat-label" style="margin-top: 15px;">Food Collected</div>
            <div class="stat-value success" id="foodCollected" style="font-size: 1.2rem;">0</div>
            
            <div class="neural-network-viz">
              <strong>Neural Network</strong><br>
              Inputs: 6 ‚Üí Hidden: 8 ‚Üí Outputs: 2<br>
              <span id="nnWeights">Weights: 0</span>
            </div>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top: 20px;">
        <div class="panel-header collapsed" onclick="togglePanel(this)">CONSOLE LOG</div>
        <div class="panel-content collapsed">
          <div class="console-log" id="consoleLog">
            <div class="log-entry log-info">
              <span class="log-timestamp">[00:00:00]</span>
              <span class="log-info"> System initialized</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================================
// ARCHITECTURE: Production-Grade Evolution Simulator
// ============================================================================
// Design Pattern: MVC + Component-Based Architecture
// - Model: NeuralNetwork, Creature, GeneticAlgorithm
// - View: Renderer, UI
// - Controller: Simulator
// ============================================================================

'use strict';

// ============================================================================
// UTILITIES: Panel Toggle
// ============================================================================
function togglePanel(header) {
  const content = header.nextElementSibling;
  const isCollapsed = content.classList.contains('collapsed');
  
  if (isCollapsed) {
    content.classList.remove('collapsed');
    header.classList.remove('collapsed');
  } else {
    content.classList.add('collapsed');
    header.classList.add('collapsed');
  }
}

// ============================================================================
// CORE: Neural Network Implementation
// ============================================================================
class NeuralNetwork {
  constructor(inputNodes, hiddenNodes, outputNodes) {
    this.inputNodes = inputNodes;
    this.hiddenNodes = hiddenNodes;
    this.outputNodes = outputNodes;
    
    // Initialize weights with Xavier initialization
    this.weightsIH = this.createMatrix(this.hiddenNodes, this.inputNodes);
    this.weightsHO = this.createMatrix(this.outputNodes, this.hiddenNodes);
    this.biasH = this.createMatrix(this.hiddenNodes, 1);
    this.biasO = this.createMatrix(this.outputNodes, 1);
    
    this.randomize();
  }
  
  createMatrix(rows, cols) {
    return Array(rows).fill().map(() => Array(cols).fill(0));
  }
  
  randomize() {
    const xavier = (fanIn, fanOut) => Math.sqrt(6 / (fanIn + fanOut));
    
    // Xavier initialization for better convergence
    const limitIH = xavier(this.inputNodes, this.hiddenNodes);
    this.mapMatrix(this.weightsIH, () => Math.random() * 2 * limitIH - limitIH);
    
    const limitHO = xavier(this.hiddenNodes, this.outputNodes);
    this.mapMatrix(this.weightsHO, () => Math.random() * 2 * limitHO - limitHO);
    
    this.mapMatrix(this.biasH, () => Math.random() * 2 - 1);
    this.mapMatrix(this.biasO, () => Math.random() * 2 - 1);
  }
  
  mapMatrix(matrix, fn) {
    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[i].length; j++) {
        matrix[i][j] = fn(matrix[i][j], i, j);
      }
    }
  }
  
  feedforward(inputArray) {
    // Convert input to column matrix
    let inputs = inputArray.map(val => [val]);
    
    // Input ‚Üí Hidden
    let hidden = this.multiply(this.weightsIH, inputs);
    hidden = this.add(hidden, this.biasH);
    hidden = this.activate(hidden, this.relu);
    
    // Hidden ‚Üí Output
    let outputs = this.multiply(this.weightsHO, hidden);
    outputs = this.add(outputs, this.biasO);
    outputs = this.activate(outputs, this.tanh);
    
    return outputs.map(row => row[0]);
  }
  
  multiply(a, b) {
    const result = [];
    for (let i = 0; i < a.length; i++) {
      result[i] = [];
      for (let j = 0; j < b[0].length; j++) {
        let sum = 0;
        for (let k = 0; k < a[0].length; k++) {
          sum += a[i][k] * b[k][j];
        }
        result[i][j] = sum;
      }
    }
    return result;
  }
  
  add(a, b) {
    return a.map((row, i) => row.map((val, j) => val + b[i][j]));
  }
  
  activate(matrix, fn) {
    return matrix.map(row => row.map(val => fn(val)));
  }
  
  relu(x) {
    return Math.max(0, x);
  }
  
  tanh(x) {
    return Math.tanh(x);
  }
  
  mutate(rate) {
    const mutateValue = (val) => {
      if (Math.random() < rate) {
        // Gaussian mutation
        const offset = this.gaussianRandom() * 0.5;
        return val + offset;
      }
      return val;
    };
    
    this.mapMatrix(this.weightsIH, mutateValue);
    this.mapMatrix(this.weightsHO, mutateValue);
    this.mapMatrix(this.biasH, mutateValue);
    this.mapMatrix(this.biasO, mutateValue);
  }
  
  gaussianRandom() {
    // Box-Muller transform
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }
  
  copy() {
    const nn = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
    nn.weightsIH = this.copyMatrix(this.weightsIH);
    nn.weightsHO = this.copyMatrix(this.weightsHO);
    nn.biasH = this.copyMatrix(this.biasH);
    nn.biasO = this.copyMatrix(this.biasO);
    return nn;
  }
  
  copyMatrix(matrix) {
    return matrix.map(row => [...row]);
  }
  
  getWeightCount() {
    return (this.inputNodes * this.hiddenNodes) + 
           (this.hiddenNodes * this.outputNodes) +
           this.hiddenNodes + this.outputNodes;
  }
}

// ============================================================================
// ENTITY: Creature
// ============================================================================
class Creature {
  constructor(x, y, brain = null) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.radius = 8;
    this.brain = brain || new NeuralNetwork(6, 8, 2);
    
    // Fitness metrics
    this.fitness = 0;
    this.distanceTraveled = 0;
    this.foodCollected = 0;
    this.alive = true;
    this.age = 0;
    
    // Physics
    this.maxSpeed = 3;
    this.acceleration = 0.2;
    this.friction = 0.95;
    
    // Visual - Use RGBA for easier alpha manipulation
    const hue = 180 + Math.random() * 60;
    this.hue = hue;
    this.color = `hsl(${hue}, 80%, 60%)`;
    this.colorRgb = this.hslToRgb(hue, 0.8, 0.6);
    this.trail = [];
    this.maxTrailLength = 20;
  }
  
  hslToRgb(h, s, l) {
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c / 2;
    let r = 0, g = 0, b = 0;
    
    if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
    else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
    else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
    else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
    else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
    else if (h >= 300 && h < 360) { r = c; g = 0; b = x; }
    
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    
    return { r, g, b };
  }
  
  think(closestFood, walls, creatures) {
    if (!this.alive) return;
    
    // Prepare inputs (normalized)
    const inputs = [
      (closestFood.x - this.x) / 800, // Food X relative
      (closestFood.y - this.y) / 600, // Food Y relative
      this.vx / this.maxSpeed,         // Current velocity X
      this.vy / this.maxSpeed,         // Current velocity Y
      this.x / 800,                    // Position X
      this.y / 600                     // Position Y
    ];
    
    // Get neural network output
    const outputs = this.brain.feedforward(inputs);
    
    // Apply outputs to movement
    this.vx += outputs[0] * this.acceleration;
    this.vy += outputs[1] * this.acceleration;
    
    // Limit speed
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
    if (speed > this.maxSpeed) {
      this.vx = (this.vx / speed) * this.maxSpeed;
      this.vy = (this.vy / speed) * this.maxSpeed;
    }
  }
  
  update(dt) {
    if (!this.alive) return;
    
    const prevX = this.x;
    const prevY = this.y;
    
    // Apply friction
    this.vx *= this.friction;
    this.vy *= this.friction;
    
    // Update position
    this.x += this.vx;
    this.y += this.vy;
    
    // Calculate distance traveled
    const dx = this.x - prevX;
    const dy = this.y - prevY;
    this.distanceTraveled += Math.sqrt(dx * dx + dy * dy);
    
    // Update trail
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > this.maxTrailLength) {
      this.trail.shift();
    }
    
    this.age += dt;
  }
  
  checkBounds(width, height) {
    if (this.x < this.radius || this.x > width - this.radius) {
      this.vx *= -0.5;
      this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
    }
    if (this.y < this.radius || this.y > height - this.radius) {
      this.vy *= -0.5;
      this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));
    }
  }
  
  eatFood(food) {
    const dx = this.x - food.x;
    const dy = this.y - food.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < this.radius + food.radius) {
      this.foodCollected++;
      return true;
    }
    return false;
  }
  
  calculateFitness() {
    // Multi-objective fitness function
    this.fitness = 
      this.foodCollected * 100 +        // Food is most important
      this.distanceTraveled * 0.1 +     // Movement is good
      this.age * 0.01;                  // Survival time matters
    
    return this.fitness;
  }
  
  crossover(partner) {
    const child = new Creature(this.x, this.y);
    child.brain = this.brain.copy();
    
    // Inherit color from one parent
    if (Math.random() < 0.5) {
      child.hue = this.hue;
      child.color = this.color;
      child.colorRgb = this.colorRgb;
    } else {
      child.hue = partner.hue;
      child.color = partner.color;
      child.colorRgb = partner.colorRgb;
    }
    
    // Crossover weights (uniform crossover)
    const crossoverWeights = (a, b) => {
      return a.map((row, i) => 
        row.map((val, j) => Math.random() < 0.5 ? val : b[i][j])
      );
    };
    
    child.brain.weightsIH = crossoverWeights(this.brain.weightsIH, partner.brain.weightsIH);
    child.brain.weightsHO = crossoverWeights(this.brain.weightsHO, partner.brain.weightsHO);
    
    return child;
  }
}

// ============================================================================
// ENTITY: Food
// ============================================================================
class Food {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 6;
    this.color = '#ffbe0b';
    this.glow = 0;
  }
  
  update(dt) {
    this.glow = (this.glow + dt * 2) % (Math.PI * 2);
  }
}

// ============================================================================
// ALGORITHM: Genetic Algorithm
// ============================================================================
class GeneticAlgorithm {
  constructor(populationSize, mutationRate) {
    this.populationSize = populationSize;
    this.mutationRate = mutationRate;
    this.generation = 0;
  }
  
  selection(population) {
    // Tournament selection
    const tournamentSize = 5;
    const selected = [];
    
    for (let i = 0; i < this.populationSize; i++) {
      const tournament = [];
      for (let j = 0; j < tournamentSize; j++) {
        const randomIndex = Math.floor(Math.random() * population.length);
        tournament.push(population[randomIndex]);
      }
      
      // Select best from tournament
      tournament.sort((a, b) => b.fitness - a.fitness);
      selected.push(tournament[0]);
    }
    
    return selected;
  }
  
  reproduce(parentA, parentB, x, y) {
    // Crossover
    const child = parentA.crossover(parentB);
    
    // Mutation
    child.brain.mutate(this.mutationRate);
    
    // Reset position
    child.x = x;
    child.y = y;
    child.vx = 0;
    child.vy = 0;
    child.fitness = 0;
    child.distanceTraveled = 0;
    child.foodCollected = 0;
    child.alive = true;
    child.age = 0;
    child.trail = [];
    
    return child;
  }
  
  evolve(population, canvasWidth, canvasHeight) {
    // Calculate fitness
    population.forEach(creature => creature.calculateFitness());
    
    // Sort by fitness
    population.sort((a, b) => b.fitness - a.fitness);
    
    // Selection
    const selected = this.selection(population);
    
    // Create new generation
    const newPopulation = [];
    
    // Elitism: Keep top 10%
    const eliteCount = Math.floor(this.populationSize * 0.1);
    for (let i = 0; i < eliteCount; i++) {
      const elite = population[i];
      const clone = new Creature(
        Math.random() * canvasWidth,
        Math.random() * canvasHeight,
        elite.brain.copy()
      );
      newPopulation.push(clone);
    }
    
    // Reproduce rest
    while (newPopulation.length < this.populationSize) {
      const parentA = selected[Math.floor(Math.random() * selected.length)];
      const parentB = selected[Math.floor(Math.random() * selected.length)];
      const child = this.reproduce(
        parentA,
        parentB,
        Math.random() * canvasWidth,
        Math.random() * canvasHeight
      );
      newPopulation.push(child);
    }
    
    this.generation++;
    return newPopulation;
  }
  
  getStatistics(population) {
    const fitnesses = population.map(c => c.fitness);
    const best = Math.max(...fitnesses);
    const avg = fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length;
    const worst = Math.min(...fitnesses);
    
    return { best, avg, worst };
  }
}

// ============================================================================
// RENDERER: Visualization Engine
// ============================================================================
class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.resize();
    
    window.addEventListener('resize', () => this.resize());
  }
  
  resize() {
    const rect = this.canvas.getBoundingClientRect();
    this.canvas.width = rect.width;
    this.canvas.height = rect.height;
  }
  
  clear() {
    this.ctx.fillStyle = '#1a2045';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw grid
    this.ctx.strokeStyle = 'rgba(0, 255, 249, 0.05)';
    this.ctx.lineWidth = 1;
    
    for (let x = 0; x < this.canvas.width; x += 40) {
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.canvas.height);
      this.ctx.stroke();
    }
    
    for (let y = 0; y < this.canvas.height; y += 40) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.canvas.width, y);
      this.ctx.stroke();
    }
  }
  
  drawCreature(creature) {
    if (!creature.alive) return;
    
    const ctx = this.ctx;
    const rgb = creature.colorRgb;
    
    // Draw trail
    if (creature.trail.length > 1) {
      ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.25)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(creature.trail[0].x, creature.trail[0].y);
      for (let i = 1; i < creature.trail.length; i++) {
        ctx.lineTo(creature.trail[i].x, creature.trail[i].y);
      }
      ctx.stroke();
    }
    
    // Draw body
    ctx.fillStyle = creature.color;
    ctx.beginPath();
    ctx.arc(creature.x, creature.y, creature.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw glow
    const gradient = ctx.createRadialGradient(
      creature.x, creature.y, 0,
      creature.x, creature.y, creature.radius * 2
    );
    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.7)`);
    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(creature.x, creature.y, creature.radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw direction indicator
    const dirX = creature.x + Math.cos(Math.atan2(creature.vy, creature.vx)) * creature.radius;
    const dirY = creature.y + Math.sin(Math.atan2(creature.vy, creature.vx)) * creature.radius;
    
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(creature.x, creature.y);
    ctx.lineTo(dirX, dirY);
    ctx.stroke();
  }
  
  drawFood(food) {
    const ctx = this.ctx;
    
    // Animated glow
    const glowRadius = food.radius + Math.sin(food.glow) * 3;
    
    const gradient = ctx.createRadialGradient(
      food.x, food.y, 0,
      food.x, food.y, glowRadius * 2
    );
    gradient.addColorStop(0, 'rgba(255, 190, 11, 1)');
    gradient.addColorStop(0.5, 'rgba(255, 190, 11, 0.5)');
    gradient.addColorStop(1, 'rgba(255, 190, 11, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(food.x, food.y, glowRadius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Core
    ctx.fillStyle = food.color;
    ctx.beginPath();
    ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============================================================================
// UI: User Interface Controller
// ============================================================================
class UI {
  constructor() {
    this.elements = {
      generation: document.getElementById('generation'),
      population: document.getElementById('population'),
      alive: document.getElementById('alive'),
      bestFitness: document.getElementById('bestFitness'),
      avgFitness: document.getElementById('avgFitness'),
      genProgress: document.getElementById('genProgress'),
      statusBadge: document.getElementById('statusBadge'),
      genomeLength: document.getElementById('genomeLength'),
      distTraveled: document.getElementById('distTraveled'),
      foodCollected: document.getElementById('foodCollected'),
      nnWeights: document.getElementById('nnWeights'),
      consoleLog: document.getElementById('consoleLog'),
    };
    
    this.fitnessHistory = [];
    this.maxHistory = 100;
    
    this.setupGraph();
  }
  
  setupGraph() {
    this.graphCanvas = document.getElementById('fitnessGraph');
    this.graphCtx = this.graphCanvas.getContext('2d');
    
    const rect = this.graphCanvas.getBoundingClientRect();
    this.graphCanvas.width = rect.width;
    this.graphCanvas.height = rect.height;
  }
  
  updateStats(stats) {
    this.elements.generation.textContent = stats.generation;
    this.elements.population.textContent = stats.population;
    this.elements.alive.textContent = stats.alive;
    this.elements.bestFitness.textContent = Math.round(stats.bestFitness);
    this.elements.avgFitness.textContent = Math.round(stats.avgFitness);
    this.elements.genProgress.style.width = stats.progress + '%';
    
    if (stats.bestCreature) {
      this.elements.genomeLength.textContent = stats.bestCreature.brain.getWeightCount();
      this.elements.distTraveled.textContent = Math.round(stats.bestCreature.distanceTraveled) + 'm';
      this.elements.foodCollected.textContent = stats.bestCreature.foodCollected;
      this.elements.nnWeights.textContent = `Weights: ${stats.bestCreature.brain.getWeightCount()}`;
    }
  }
  
  updateStatus(status) {
    const badge = this.elements.statusBadge;
    badge.className = `status-badge ${status.toLowerCase()}`;
    badge.textContent = status;
  }
  
  addLog(message, type = 'info') {
    const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    entry.innerHTML = `
      <span class="log-timestamp">[${timestamp}]</span>
      <span class="log-${type}"> ${message}</span>
    `;
    
    this.elements.consoleLog.appendChild(entry);
    this.elements.consoleLog.scrollTop = this.elements.consoleLog.scrollHeight;
    
    // Limit log entries
    while (this.elements.consoleLog.children.length > 50) {
      this.elements.consoleLog.removeChild(this.elements.consoleLog.firstChild);
    }
  }
  
  updateGraph(generation, bestFitness, avgFitness) {
    this.fitnessHistory.push({ generation, best: bestFitness, avg: avgFitness });
    
    if (this.fitnessHistory.length > this.maxHistory) {
      this.fitnessHistory.shift();
    }
    
    this.drawGraph();
  }
  
  drawGraph() {
    const ctx = this.graphCtx;
    const width = this.graphCanvas.width;
    const height = this.graphCanvas.height;
    
    // Clear
    ctx.fillStyle = '#1a2045';
    ctx.fillRect(0, 0, width, height);
    
    if (this.fitnessHistory.length < 2) return;
    
    // Find max fitness for scaling
    const maxFitness = Math.max(...this.fitnessHistory.map(h => h.best));
    
    // Draw grid
    ctx.strokeStyle = 'rgba(0, 255, 249, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const y = (height / 5) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
    
    // Draw best fitness line
    ctx.strokeStyle = '#00fff9';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    this.fitnessHistory.forEach((point, i) => {
      const x = (i / (this.fitnessHistory.length - 1)) * width;
      const y = height - (point.best / maxFitness) * height;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    ctx.stroke();
    
    // Draw average fitness line
    ctx.strokeStyle = '#ff006e';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    this.fitnessHistory.forEach((point, i) => {
      const x = (i / (this.fitnessHistory.length - 1)) * width;
      const y = height - (point.avg / maxFitness) * height;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    ctx.stroke();
  }
}

// ============================================================================
// CONTROLLER: Main Simulator
// ============================================================================
class Simulator {
  constructor() {
    this.canvas = document.getElementById('simulationCanvas');
    this.renderer = new Renderer(this.canvas);
    this.ui = new UI();
    
    // Configuration
    this.config = {
      populationSize: 50,
      mutationRate: 0.1,
      generationTime: 10000, // ms
      foodCount: 30
    };
    
    // State
    this.running = false;
    this.speed = 1;
    this.generation = 0;
    this.generationStartTime = 0;
    
    // Entities
    this.creatures = [];
    this.food = [];
    this.ga = new GeneticAlgorithm(this.config.populationSize, this.config.mutationRate);
    
    // Animation
    this.lastTime = 0;
    this.animationId = null;
    
    this.setupControls();
    this.initialize();
  }
  
  initialize() {
    this.ui.addLog('Initializing simulation...', 'info');
    
    // Create initial population
    this.creatures = [];
    for (let i = 0; i < this.config.populationSize; i++) {
      const x = Math.random() * this.canvas.width;
      const y = Math.random() * this.canvas.height;
      this.creatures.push(new Creature(x, y));
    }
    
    // Create food
    this.spawnFood();
    
    this.ui.addLog(`Population created: ${this.config.populationSize} creatures`, 'success');
    this.ui.updateStatus('STOPPED');
    
    // Initial render
    this.render();
  }
  
  spawnFood() {
    this.food = [];
    for (let i = 0; i < this.config.foodCount; i++) {
      const x = Math.random() * this.canvas.width;
      const y = Math.random() * this.canvas.height;
      this.food.push(new Food(x, y));
    }
  }
  
  setupControls() {
    // Start/Stop
    document.getElementById('startBtn').addEventListener('click', () => {
      if (!this.running) {
        this.start();
      }
    });
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
      this.pause();
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      this.reset();
    });
    
    // Speed control
    document.getElementById('speedBtn').addEventListener('click', (e) => {
      this.speed = this.speed === 1 ? 2 : this.speed === 2 ? 4 : 1;
      e.target.textContent = `SPEED: ${this.speed}x`;
      this.ui.addLog(`Speed changed to ${this.speed}x`, 'info');
    });
    
    // Settings
    document.getElementById('popSize').addEventListener('input', (e) => {
      this.config.populationSize = parseInt(e.target.value);
      document.getElementById('popSizeValue').textContent = e.target.value;
      this.ga.populationSize = this.config.populationSize;
    });
    
    document.getElementById('mutRate').addEventListener('input', (e) => {
      this.config.mutationRate = parseFloat(e.target.value);
      document.getElementById('mutRateValue').textContent = e.target.value;
      this.ga.mutationRate = this.config.mutationRate;
    });
    
    document.getElementById('genTime').addEventListener('input', (e) => {
      this.config.generationTime = parseInt(e.target.value) * 1000;
      document.getElementById('genTimeValue').textContent = e.target.value + 's';
    });
  }
  
  start() {
    if (this.running) return;
    
    this.running = true;
    this.generationStartTime = Date.now();
    this.ui.updateStatus('RUNNING');
    this.ui.addLog('Simulation started', 'success');
    
    this.lastTime = performance.now();
    this.animate(this.lastTime);
  }
  
  pause() {
    this.running = false;
    this.ui.updateStatus('PAUSED');
    this.ui.addLog('Simulation paused', 'warning');
    
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
  
  reset() {
    this.pause();
    this.generation = 0;
    this.ga.generation = 0;
    this.initialize();
    this.ui.addLog('Simulation reset', 'info');
    this.ui.fitnessHistory = [];
  }
  
  animate(currentTime) {
    if (!this.running) return;
    
    const deltaTime = (currentTime - this.lastTime) * this.speed;
    this.lastTime = currentTime;
    
    this.update(deltaTime);
    this.render();
    
    this.animationId = requestAnimationFrame((time) => this.animate(time));
  }
  
  update(dt) {
    // Update food
    this.food.forEach(food => food.update(dt / 1000));
    
    // Update creatures
    this.creatures.forEach(creature => {
      if (!creature.alive) return;
      
      // Find closest food
      let closestFood = this.food[0];
      let closestDist = Infinity;
      
      this.food.forEach(food => {
        const dx = food.x - creature.x;
        const dy = food.y - creature.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < closestDist) {
          closestDist = dist;
          closestFood = food;
        }
      });
      
      // Think and move
      creature.think(closestFood, [], this.creatures);
      creature.update(dt / 1000);
      creature.checkBounds(this.canvas.width, this.canvas.height);
      
      // Check food collision
      for (let i = this.food.length - 1; i >= 0; i--) {
        if (creature.eatFood(this.food[i])) {
          // Respawn food
          this.food[i].x = Math.random() * this.canvas.width;
          this.food[i].y = Math.random() * this.canvas.height;
        }
      }
    });
    
    // Check generation time
    const elapsed = Date.now() - this.generationStartTime;
    const progress = (elapsed / this.config.generationTime) * 100;
    
    if (elapsed >= this.config.generationTime) {
      this.nextGeneration();
    }
    
    // Update UI
    const stats = this.ga.getStatistics(this.creatures);
    const aliveCount = this.creatures.filter(c => c.alive).length;
    const bestCreature = this.creatures.reduce((best, current) => 
      current.fitness > best.fitness ? current : best
    );
    
    this.ui.updateStats({
      generation: this.ga.generation,
      population: this.creatures.length,
      alive: aliveCount,
      bestFitness: stats.best,
      avgFitness: stats.avg,
      progress: Math.min(progress, 100),
      bestCreature: bestCreature
    });
  }
  
  nextGeneration() {
    const stats = this.ga.getStatistics(this.creatures);
    
    this.ui.addLog(
      `Gen ${this.ga.generation} complete. Best: ${Math.round(stats.best)} | Avg: ${Math.round(stats.avg)}`,
      'success'
    );
    
    this.ui.updateGraph(this.ga.generation, stats.best, stats.avg);
    
    // Evolve
    this.creatures = this.ga.evolve(this.creatures, this.canvas.width, this.canvas.height);
    
    // Reset timer
    this.generationStartTime = Date.now();
    
    // Respawn food
    this.spawnFood();
    
    this.ui.addLog(`Generation ${this.ga.generation} started`, 'info');
  }
  
  render() {
    this.renderer.clear();
    
    // Draw food
    this.food.forEach(food => this.renderer.drawFood(food));
    
    // Draw creatures
    this.creatures.forEach(creature => this.renderer.drawCreature(creature));
  }
}

// ============================================================================
// INITIALIZATION
// ============================================================================
window.addEventListener('DOMContentLoaded', () => {
  const loading = document.getElementById('loading');
  loading.classList.add('active');
  
  setTimeout(() => {
    const simulator = new Simulator();
    loading.classList.remove('active');
  }, 1000);
});
</script>

</body>
</html>
